1
00:00:00,000 --> 00:00:05,000
All right, so we are getting into the second half

2
00:00:06,920 --> 00:00:07,840
of the semester, right?

3
00:00:07,840 --> 00:00:10,520
And we have some really good stuff lined up.

4
00:00:10,520 --> 00:00:15,040
So first of all, today's lecture will be a couple

5
00:00:15,040 --> 00:00:17,600
of more graphics pipeline stuff following

6
00:00:17,600 --> 00:00:19,640
from last time around.

7
00:00:19,640 --> 00:00:21,360
We'd also have the Project 4 recitation,

8
00:00:21,360 --> 00:00:24,120
which you may or may not choose to build

9
00:00:24,120 --> 00:00:26,440
upon your Project 3.

10
00:00:26,440 --> 00:00:27,880
If you don't choose to build upon it,

11
00:00:27,880 --> 00:00:30,960
we have a base code that you can get started with.

12
00:00:31,880 --> 00:00:36,520
On October 12th, we'll do likely a last CUDA-specific

13
00:00:36,520 --> 00:00:38,040
lecture, which will be advanced topics

14
00:00:38,040 --> 00:00:41,520
where I'll be talking about streams and other things.

15
00:00:43,480 --> 00:00:45,440
October 17th and 19th will be really good,

16
00:00:45,440 --> 00:00:48,120
especially for those of you who are interested

17
00:00:48,120 --> 00:00:49,760
in machine learning.

18
00:00:49,760 --> 00:00:54,280
Liam Duggan, who was a student in 2018,

19
00:00:55,240 --> 00:00:59,800
did the first DXR project, DirectX Ray Tracing Project

20
00:00:59,800 --> 00:01:00,640
as final projects.

21
00:01:00,640 --> 00:01:02,560
He was part of that team.

22
00:01:02,560 --> 00:01:06,960
Went to NVIDIA, came back to Penn to do machine learning PhD

23
00:01:06,960 --> 00:01:10,280
in natural language processing, interned at Roblox

24
00:01:10,280 --> 00:01:14,040
over the summer with Morgan McGuire.

25
00:01:14,040 --> 00:01:17,600
And he did two lectures in the class last year

26
00:01:17,600 --> 00:01:19,560
on machine learning and CUDA, and he's coming back

27
00:01:19,560 --> 00:01:21,400
to do those two lectures again.

28
00:01:21,400 --> 00:01:24,160
So both of those will happen next week.

29
00:01:25,000 --> 00:01:28,720
Simultaneously, we'll have an introduction to WebGL,

30
00:01:28,720 --> 00:01:31,920
which will set up one part of project five,

31
00:01:31,920 --> 00:01:33,600
and then we'll do an intro to Vulkan

32
00:01:33,600 --> 00:01:36,200
that will be pre-recorded and shared with you

33
00:01:36,200 --> 00:01:38,640
from last year, so we'll re-share that.

34
00:01:39,520 --> 00:01:43,000
But both of those will be introductions for APIs

35
00:01:43,000 --> 00:01:45,120
that you may use for project five.

36
00:01:46,440 --> 00:01:48,320
On Wednesday, we'll actually have the recitation

37
00:01:48,320 --> 00:01:51,000
for project five, which will be an option

38
00:01:51,000 --> 00:01:54,080
between a WebGL project or a Vulkan project.

39
00:01:55,000 --> 00:01:55,840
It's up to you to choose which one.

40
00:01:55,840 --> 00:01:59,160
They're both graded equally, so there's no difference

41
00:01:59,160 --> 00:02:00,680
in picking one or the other.

42
00:02:00,680 --> 00:02:03,280
It's really up to you to choose what you want.

43
00:02:03,280 --> 00:02:06,400
The only thing that we say to think about

44
00:02:06,400 --> 00:02:10,840
is whether you want to do a Web-based final project

45
00:02:10,840 --> 00:02:12,840
or a Vulkan-based final project,

46
00:02:12,840 --> 00:02:16,720
or CUDA you already know, so CUDA will obviously be there,

47
00:02:16,720 --> 00:02:19,840
but it really depends on which path you may want to go on.

48
00:02:19,840 --> 00:02:21,520
So that's setting up next week.

49
00:02:22,520 --> 00:02:27,280
And then project four will be due at the end of that.

50
00:02:27,280 --> 00:02:31,800
October 24th is an amazing guest lecture by Brandon Jones.

51
00:02:31,800 --> 00:02:35,480
Brandon Jones has been involved in web graphics standards

52
00:02:35,480 --> 00:02:37,360
since before I got into graphics.

53
00:02:38,560 --> 00:02:40,360
He's part of the Chrome GPU team.

54
00:02:40,360 --> 00:02:44,120
He's worked extensively on the WebGL standard

55
00:02:44,120 --> 00:02:46,600
and its implementation, and for the past few years

56
00:02:46,600 --> 00:02:48,600
has been working on the WebGPU standard

57
00:02:48,600 --> 00:02:50,240
and its implementations.

58
00:02:50,440 --> 00:02:51,640
And he'll be coming in person.

59
00:02:51,640 --> 00:02:53,880
He'll be spending the day with us.

60
00:02:53,880 --> 00:02:56,720
And then in the evening, he'll be giving the guest lecture.

61
00:02:56,720 --> 00:02:59,320
And I'll be opening that invite up to the broader

62
00:02:59,320 --> 00:03:01,440
CGI Penn community as well,

63
00:03:01,440 --> 00:03:03,720
so that if anybody outside wants to join,

64
00:03:03,720 --> 00:03:05,920
and please feel free to advertise it to your friends as well

65
00:03:05,920 --> 00:03:07,720
who may be interested in this.

66
00:03:07,720 --> 00:03:11,800
WebGL, if a simple comparison between WebGL and WebGPU

67
00:03:11,800 --> 00:03:13,720
is kind of like OpenGL and Vulkan,

68
00:03:13,720 --> 00:03:15,680
WebGPU gives you a lot more power,

69
00:03:16,600 --> 00:03:17,760
and it's an up-and-coming standard.

70
00:03:17,760 --> 00:03:21,200
We had three final projects on WebGPU last year,

71
00:03:21,200 --> 00:03:22,560
which was great.

72
00:03:22,560 --> 00:03:25,240
Hope to have similar, if not more, this year.

73
00:03:25,240 --> 00:03:26,480
So Brandon Jones is going to do

74
00:03:26,480 --> 00:03:28,120
an amazing guest lecture on that.

75
00:03:29,840 --> 00:03:33,200
October 26th, we'll do the final projects overview.

76
00:03:33,200 --> 00:03:36,920
So that class will just be talking about final projects,

77
00:03:36,920 --> 00:03:40,320
answering your questions, giving you some ideas and stuff.

78
00:03:40,320 --> 00:03:43,560
So we'll do that on October 26th.

79
00:03:43,560 --> 00:03:45,240
October 31st is TBD.

80
00:03:45,280 --> 00:03:48,200
I'm not completely sure what I'm going to do then,

81
00:03:48,200 --> 00:03:50,680
but on November 2nd, we'll have Jim Jeffers,

82
00:03:50,680 --> 00:03:53,440
who is a principal engineer

83
00:03:53,440 --> 00:03:56,600
and director of advanced rendering at Intel.

84
00:03:56,600 --> 00:04:01,400
He's worked extensively with Intel's ArcGPUs and OneAPI.

85
00:04:01,400 --> 00:04:05,240
So kind of like how NVIDIA has CUDA,

86
00:04:05,240 --> 00:04:07,600
AMD has their open pipelines,

87
00:04:07,600 --> 00:04:09,680
and then Intel has the OneAPI.

88
00:04:09,680 --> 00:04:13,320
So he's going to be coming to, again, in-person

89
00:04:13,320 --> 00:04:17,040
and talking about how they're working on rendering here.

90
00:04:18,600 --> 00:04:20,840
November 7th will be the final project pitches.

91
00:04:20,840 --> 00:04:23,120
I'll talk more about what exactly those are

92
00:04:23,120 --> 00:04:25,400
in my final projects overview.

93
00:04:25,400 --> 00:04:27,240
November 9th is Gabe Dagani.

94
00:04:27,240 --> 00:04:30,680
So this was, after a few years,

95
00:04:30,680 --> 00:04:33,760
you're having a proper mobile GPU lecture

96
00:04:33,760 --> 00:04:34,960
going to be happening in this class.

97
00:04:34,960 --> 00:04:37,000
Very excited about that.

98
00:04:37,000 --> 00:04:37,920
He's going to be great.

99
00:04:37,920 --> 00:04:38,840
He's also interviewing.

100
00:04:38,840 --> 00:04:42,960
I did post a job post on a discussion for it.

101
00:04:42,960 --> 00:04:43,960
If you're interested, you know,

102
00:04:43,960 --> 00:04:45,440
please feel free to reach out.

103
00:04:46,640 --> 00:04:51,640
October 14th, this was just confirmed Thursday or Friday.

104
00:04:52,800 --> 00:04:54,680
Rev Lebredian.

105
00:04:54,680 --> 00:04:57,360
Those of you who may not know the name,

106
00:04:57,360 --> 00:05:00,480
Rev is the vice president of NVIDIA Omniverse.

107
00:05:00,480 --> 00:05:03,640
To give you a sense of how big that is,

108
00:05:03,640 --> 00:05:06,560
he manages a team of, or a group of,

109
00:05:06,560 --> 00:05:09,400
over 200 plus people at NVIDIA.

110
00:05:09,400 --> 00:05:13,880
And if you paid, if you watched the SIGGRAPH keynote,

111
00:05:13,880 --> 00:05:15,800
the NVIDIA keynote at SIGGRAPH,

112
00:05:15,800 --> 00:05:20,000
Rev was there beside Jensen talking about NVIDIA's vision

113
00:05:20,000 --> 00:05:22,560
for Omniverse, Metaverse, and things like that.

114
00:05:22,560 --> 00:05:24,560
He's coming in person to talk to you.

115
00:05:24,560 --> 00:05:27,200
Like Rev could be a keynote speaker

116
00:05:27,200 --> 00:05:29,360
at any graphics conference you want,

117
00:05:29,360 --> 00:05:31,560
literally any graphics conference you want.

118
00:05:31,560 --> 00:05:32,600
And he's coming here.

119
00:05:32,600 --> 00:05:34,320
He'd be standing here in this classroom

120
00:05:34,320 --> 00:05:35,840
and giving a guest lecture.

121
00:05:35,840 --> 00:05:38,240
So I'm super excited for that.

122
00:05:38,240 --> 00:05:40,440
It's going to be a great guest lecture on USD,

123
00:05:40,440 --> 00:05:43,440
NVIDIA, Omniverse, those kinds of things.

124
00:05:43,440 --> 00:05:46,560
If you are interested in talking to him

125
00:05:46,560 --> 00:05:48,280
about career opportunities and stuff,

126
00:05:48,280 --> 00:05:51,680
he's very well known in the industry.

127
00:05:51,680 --> 00:05:53,480
His background comes from rendering.

128
00:05:53,480 --> 00:05:57,720
He was, he wrote a rendering pipeline.

129
00:05:57,720 --> 00:06:01,200
He started his own company, sold that pipeline,

130
00:06:01,200 --> 00:06:03,480
joined NVIDIA, did a bunch of stuff at NVIDIA,

131
00:06:03,480 --> 00:06:05,520
and now is leading the Omniverse team.

132
00:06:05,520 --> 00:06:08,400
So that is likely our final guest lecture.

133
00:06:08,400 --> 00:06:12,240
The only one that I'm figuring out is one from Epic Games.

134
00:06:13,240 --> 00:06:16,200
I'm trying to organize who it might be.

135
00:06:16,200 --> 00:06:19,040
The issue is I'm trying to get the Nanite team,

136
00:06:19,040 --> 00:06:21,280
but the Nanite team is busy.

137
00:06:21,280 --> 00:06:23,800
So they always have like a fall release,

138
00:06:23,800 --> 00:06:24,960
so they get busy around that.

139
00:06:24,960 --> 00:06:27,760
So it doesn't always work out for me

140
00:06:27,760 --> 00:06:28,840
to get somebody from Nanite,

141
00:06:28,840 --> 00:06:31,040
but fingers crossed we'll get somebody good.

142
00:06:32,880 --> 00:06:34,320
So yeah, that's about it.

143
00:06:34,320 --> 00:06:35,360
I'm super excited.

144
00:06:35,360 --> 00:06:37,960
All of these four guest lectures that we have coming up

145
00:06:37,960 --> 00:06:41,400
are like A plus in their fields.

146
00:06:41,400 --> 00:06:43,720
They're literally leading the charge

147
00:06:43,720 --> 00:06:47,040
in innovating standards and stuff.

148
00:06:47,040 --> 00:06:49,800
So yeah, I'm super excited about those.

149
00:06:51,040 --> 00:06:52,520
Any questions on the schedule?

150
00:06:55,720 --> 00:06:57,080
Okay.

151
00:06:57,080 --> 00:07:00,480
And a reminder, because I know some of you have asked me,

152
00:07:00,480 --> 00:07:04,000
there are no extra days for final projects.

153
00:07:05,000 --> 00:07:05,840
So don't save up on them.

154
00:07:05,840 --> 00:07:08,360
If you haven't used them for project three,

155
00:07:08,360 --> 00:07:10,240
use them for project four and project five.

156
00:07:10,240 --> 00:07:12,160
Do the extra credits and stuff.

157
00:07:12,160 --> 00:07:13,680
There's no point saving it.

158
00:07:13,680 --> 00:07:14,960
Don't come to me and be like,

159
00:07:14,960 --> 00:07:16,640
hey, I have two extra days left.

160
00:07:16,640 --> 00:07:20,680
Can I get an A minus from a B plus or whatever?

161
00:07:20,680 --> 00:07:23,440
No, I don't reward extra days being left over.

162
00:07:23,440 --> 00:07:27,680
Use them and work towards your page for that.

163
00:07:27,680 --> 00:07:28,520
Okay.

164
00:07:29,480 --> 00:07:30,320
And like,

165
00:07:33,160 --> 00:07:34,000
Yes.

166
00:07:34,000 --> 00:07:36,800
So that's these milestone things here.

167
00:07:36,800 --> 00:07:38,000
We'll have three milestones.

168
00:07:38,000 --> 00:07:41,520
I'll explain all of that in the final project overview.

169
00:07:41,520 --> 00:07:43,960
There's no late days on any final project things.

170
00:07:47,760 --> 00:07:48,840
Any other questions?

171
00:07:50,360 --> 00:07:51,200
All right.

172
00:07:52,800 --> 00:07:56,880
So with that, let's get into our lecture today.

173
00:07:59,520 --> 00:08:00,360
All right.

174
00:08:01,640 --> 00:08:03,600
So last time around,

175
00:08:03,600 --> 00:08:05,400
we spoke about the graphics pipeline, right?

176
00:08:05,400 --> 00:08:08,960
About how we go from taking points,

177
00:08:08,960 --> 00:08:10,800
making them into triangles,

178
00:08:10,800 --> 00:08:14,600
projecting them and then eventually rendering them, right?

179
00:08:14,600 --> 00:08:18,040
With vertex shaders, fragment shaders and stuff like that.

180
00:08:18,040 --> 00:08:20,440
Today, what we're going to talk about is

181
00:08:20,440 --> 00:08:23,280
how do you take that pipeline and change it up

182
00:08:23,280 --> 00:08:25,880
so that you can add more performance to it?

183
00:08:25,880 --> 00:08:27,040
Okay.

184
00:08:27,040 --> 00:08:31,560
So the first of those is called a deferred shading pipeline.

185
00:08:31,560 --> 00:08:32,920
And we look at that today.

186
00:08:34,200 --> 00:08:39,200
So the basics are that you want to design a rendering engine

187
00:08:40,680 --> 00:08:43,880
that renders a lot of different materials,

188
00:08:43,880 --> 00:08:47,280
a lot of lights and a lot of different types of lights.

189
00:08:47,280 --> 00:08:49,240
And this is true about any game you see

190
00:08:49,240 --> 00:08:52,280
or pretty much any 3D application you see,

191
00:08:52,280 --> 00:08:55,680
where you have different materials, different objects,

192
00:08:55,680 --> 00:08:57,360
lots of lights going on.

193
00:08:57,360 --> 00:09:02,360
Even if you think of like GPA, for example, right?

194
00:09:02,440 --> 00:09:04,920
You have a city environment, you have street lights,

195
00:09:04,920 --> 00:09:07,160
you have people wearing different clothes,

196
00:09:07,160 --> 00:09:10,840
you have hair, you have rigid body physics,

197
00:09:10,840 --> 00:09:12,840
you have gravity that goes crazy.

198
00:09:13,680 --> 00:09:18,360
So all of these things need to be taken into account

199
00:09:18,360 --> 00:09:20,720
and be done cleanly and efficiently

200
00:09:20,720 --> 00:09:24,000
in a way that the game can be maintained.

201
00:09:24,200 --> 00:09:26,520
You can provide upgrades and stuff like that.

202
00:09:28,080 --> 00:09:32,800
So the most common way of doing this

203
00:09:32,800 --> 00:09:34,640
was with multi-pass shading.

204
00:09:35,560 --> 00:09:39,280
Multi-pass shading is in a way very simple

205
00:09:39,280 --> 00:09:42,480
where you take that graphics pipeline you have

206
00:09:42,480 --> 00:09:45,320
and you do it multiple times per frame.

207
00:09:45,320 --> 00:09:49,120
So essentially what you do is for each light that you have,

208
00:09:50,200 --> 00:09:52,800
then you choose every visible object you have,

209
00:09:52,800 --> 00:09:56,760
you render that object, accumulate it in the frame buffer

210
00:09:56,760 --> 00:09:59,840
and then keep doing that, okay?

211
00:09:59,840 --> 00:10:01,920
Now it's pretty obvious what's wrong with this, right?

212
00:10:01,920 --> 00:10:03,480
Or what's good about it or not.

213
00:10:04,600 --> 00:10:06,360
What's something good about this?

214
00:10:10,960 --> 00:10:12,920
Yeah, sorry?

215
00:10:14,480 --> 00:10:16,880
Yeah, you won't miss an object, that's for sure.

216
00:10:16,880 --> 00:10:17,720
What else?

217
00:10:17,720 --> 00:10:18,560
Yeah.

218
00:10:22,160 --> 00:10:23,640
What else is good about this?

219
00:10:28,640 --> 00:10:31,080
You're covering the major sources of light, okay.

220
00:10:34,240 --> 00:10:35,440
What's bad about this?

221
00:10:39,960 --> 00:10:40,800
Sorry, I'm just curious.

222
00:10:40,800 --> 00:10:44,000
It's like every colorless is affected to this.

223
00:10:44,000 --> 00:10:44,840
Yeah.

224
00:10:44,840 --> 00:10:45,680
Yeah.

225
00:10:48,240 --> 00:10:51,640
So that's going probably two levels deeper.

226
00:10:51,640 --> 00:10:55,040
But if you come back, your question is,

227
00:10:55,040 --> 00:10:57,800
do materials matter, right?

228
00:10:57,800 --> 00:11:00,640
If you come two levels higher,

229
00:11:00,640 --> 00:11:02,120
do materials and light matter?

230
00:11:02,120 --> 00:11:03,240
Yes, absolutely.

231
00:11:03,240 --> 00:11:05,880
If you have three different types of light,

232
00:11:05,880 --> 00:11:09,840
one point light, one direction light, one ambient light,

233
00:11:09,840 --> 00:11:13,240
and you are trying to see how one material gets lit up

234
00:11:13,240 --> 00:11:15,520
or a hundred materials lit up,

235
00:11:15,520 --> 00:11:17,200
every one of them is gonna act differently

236
00:11:17,200 --> 00:11:18,360
with different types of light.

237
00:11:18,360 --> 00:11:22,400
So in this case, one of the pros is that

238
00:11:22,400 --> 00:11:25,840
you can have one shader that is handling all material,

239
00:11:27,240 --> 00:11:32,240
that is handling one material and light combination, okay?

240
00:11:32,800 --> 00:11:35,200
So for every type of light,

241
00:11:35,200 --> 00:11:37,880
you will have one shader for every material.

242
00:11:37,880 --> 00:11:39,160
So it's like N times N.

243
00:11:39,160 --> 00:11:42,720
So imagine as a game engine writer,

244
00:11:43,480 --> 00:11:44,920
you have to manage all of that.

245
00:11:44,920 --> 00:11:45,880
You'll go crazy.

246
00:11:45,880 --> 00:11:48,560
I mean, even in this room, see how many lights we have.

247
00:11:48,560 --> 00:11:50,960
Right, so that becomes very, very complicated.

248
00:11:52,560 --> 00:11:55,080
What else is the problem with this?

249
00:11:55,080 --> 00:11:56,720
I think you had your hand raised.

250
00:12:01,880 --> 00:12:02,920
Yeah, absolutely.

251
00:12:02,920 --> 00:12:04,800
You're wasting time on occluded objects.

252
00:12:04,800 --> 00:12:07,240
If something's super in the background

253
00:12:07,240 --> 00:12:09,680
and you're pretty sure not to be able to see it,

254
00:12:09,680 --> 00:12:11,240
you're gonna be wasting time

255
00:12:11,240 --> 00:12:13,040
rendering this in this double form.

256
00:12:14,680 --> 00:12:15,520
What else?

257
00:12:19,920 --> 00:12:22,080
So here are some more, okay?

258
00:12:22,080 --> 00:12:24,880
We covered one shader per material and light type.

259
00:12:25,960 --> 00:12:28,720
I discovered occluded fragments are shaded.

260
00:12:30,360 --> 00:12:31,720
This one is important as well.

261
00:12:31,720 --> 00:12:34,400
Not all lights affect all the objects.

262
00:12:34,400 --> 00:12:36,360
A light in that corner of that room

263
00:12:36,360 --> 00:12:37,880
is not really going to affect me

264
00:12:37,880 --> 00:12:40,400
when I have a light right above me, right?

265
00:12:40,400 --> 00:12:43,280
So the significance of any light in the room

266
00:12:43,280 --> 00:12:45,840
doesn't count the same for all the objects.

267
00:12:47,120 --> 00:12:50,040
And then you have to do the rasterization.

268
00:12:50,040 --> 00:12:53,000
You have to do the entire pipeline for each object

269
00:12:53,000 --> 00:12:54,040
for every light.

270
00:12:54,040 --> 00:12:55,880
And that means more pipeline stages

271
00:12:55,880 --> 00:12:57,960
doing the same thing over and over again.

272
00:12:58,920 --> 00:13:01,200
So those are some issues.

273
00:13:02,640 --> 00:13:04,920
Now, if you change that to a single pass,

274
00:13:05,880 --> 00:13:07,040
then you get something like this.

275
00:13:07,040 --> 00:13:08,440
For each visible object,

276
00:13:09,440 --> 00:13:12,360
you try to find all the lights that actually affect.

277
00:13:12,360 --> 00:13:13,720
Okay, so I'm standing in this corner.

278
00:13:13,720 --> 00:13:15,800
I'll probably get affected by that light

279
00:13:15,800 --> 00:13:17,040
and maybe that light.

280
00:13:17,040 --> 00:13:20,360
Not getting affected by that light in the last row.

281
00:13:20,360 --> 00:13:24,840
So that reduces how many passes you have to do,

282
00:13:25,760 --> 00:13:28,720
but then it has its own cons as well.

283
00:13:30,000 --> 00:13:31,440
Some of those cons,

284
00:13:31,440 --> 00:13:34,080
and now you need one shader per light combination

285
00:13:34,080 --> 00:13:34,920
like before.

286
00:13:36,040 --> 00:13:38,400
It's hard to create all of those shaders

287
00:13:39,240 --> 00:13:42,760
because now you have to write complex code

288
00:13:42,760 --> 00:13:46,040
for which light is affecting what type of light

289
00:13:46,040 --> 00:13:46,880
and all that.

290
00:13:48,320 --> 00:13:50,200
It may require runtime compilation

291
00:13:50,200 --> 00:13:53,320
because let's say objects are moving through the scene,

292
00:13:53,320 --> 00:13:56,600
they're gonna be interacting with different things.

293
00:13:56,600 --> 00:13:58,800
Sometimes you have to create long over shaders

294
00:13:58,800 --> 00:14:01,360
for managing a lot of different materials.

295
00:14:02,480 --> 00:14:04,800
So not the best thing.

296
00:14:05,800 --> 00:14:09,440
And you still get the same issues as before

297
00:14:09,440 --> 00:14:12,840
where you are still rendering occluded objects

298
00:14:12,840 --> 00:14:15,720
and still have light issues, okay?

299
00:14:15,720 --> 00:14:17,840
And so because there are so many

300
00:14:17,840 --> 00:14:19,280
of these different combinations,

301
00:14:19,280 --> 00:14:22,440
you can have different lights, different materials.

302
00:14:22,440 --> 00:14:24,960
Some of these are being compiled at runtime.

303
00:14:24,960 --> 00:14:26,880
And this is something that happens in every game engine.

304
00:14:26,880 --> 00:14:29,040
Not all game engines come with pre-compiled shaders.

305
00:14:29,040 --> 00:14:31,920
Some of those are actually happening at runtime,

306
00:14:31,920 --> 00:14:33,880
but because they happen fast enough,

307
00:14:34,360 --> 00:14:35,440
they get hidden.

308
00:14:36,560 --> 00:14:39,360
So still not great.

309
00:14:39,360 --> 00:14:41,400
We still have quite a few issues here.

310
00:14:43,080 --> 00:14:47,080
So what we, and I say we collectively

311
00:14:47,080 --> 00:14:48,440
in the broader community,

312
00:14:48,440 --> 00:14:50,600
people a lot smarter than myself,

313
00:14:50,600 --> 00:14:52,560
especially in the games industry,

314
00:14:52,560 --> 00:14:54,720
have come up with what is known

315
00:14:54,720 --> 00:14:58,160
as a deferred rendering pipeline, okay?

316
00:14:58,160 --> 00:15:01,120
In this pipeline, there are two stages essentially.

317
00:15:02,120 --> 00:15:03,480
In the first stage,

318
00:15:03,480 --> 00:15:05,960
you're computing all the visible objects.

319
00:15:07,360 --> 00:15:09,560
And these visible objects then get written

320
00:15:09,560 --> 00:15:11,800
to what is known as a G-buffer

321
00:15:11,800 --> 00:15:14,520
or more commonly as a geometry buffer.

322
00:15:14,520 --> 00:15:16,640
The geometry buffer essentially stores

323
00:15:16,640 --> 00:15:18,480
the visible part of the scene.

324
00:15:18,480 --> 00:15:20,360
And we'll see how that works.

325
00:15:21,280 --> 00:15:23,680
And then what you do is you break that up.

326
00:15:23,680 --> 00:15:27,560
And then in stage two, for each light,

327
00:15:27,560 --> 00:15:30,880
you only work on the G-buffer.

328
00:15:31,640 --> 00:15:33,240
So only on the visible part of the scene.

329
00:15:33,240 --> 00:15:35,240
That way you don't render anything

330
00:15:35,240 --> 00:15:36,800
that's occluded, for example.

331
00:15:37,880 --> 00:15:40,720
So let's take a look at how this works.

332
00:15:40,720 --> 00:15:42,840
Starting with the pros and cons.

333
00:15:42,840 --> 00:15:45,320
So the first thing is you're decoupling lights

334
00:15:45,320 --> 00:15:46,800
from the scene complexity.

335
00:15:46,800 --> 00:15:49,840
So no matter how many triangles you have in your scene,

336
00:15:49,840 --> 00:15:52,680
no matter how many materials you have in your scene,

337
00:15:52,680 --> 00:15:55,000
the lighting is decoupled from that.

338
00:15:55,000 --> 00:15:56,880
You are rendering the visible part first

339
00:15:56,880 --> 00:16:00,480
and then the lighting will only work on the visible part.

340
00:16:00,480 --> 00:16:01,880
You reduce the number of shaders.

341
00:16:01,880 --> 00:16:05,120
So now you have one per material and one per light type.

342
00:16:08,160 --> 00:16:11,560
And because we store the G-buffer,

343
00:16:11,560 --> 00:16:14,360
you're transforming and rasterizing only once.

344
00:16:14,360 --> 00:16:17,240
The G-buffer comes after rasterization.

345
00:16:17,240 --> 00:16:19,240
And finally, as I said before,

346
00:16:19,240 --> 00:16:22,080
you're not rendering occluded objects.

347
00:16:22,080 --> 00:16:24,880
So all the lights are working only on visible parts.

348
00:16:27,280 --> 00:16:28,680
Possible downsides.

349
00:16:29,680 --> 00:16:32,000
It could lead into memory bandwidth issues.

350
00:16:32,000 --> 00:16:34,640
And we'll talk about this in a little bit.

351
00:16:34,640 --> 00:16:36,560
Essentially because you're reading the G-buffer

352
00:16:36,560 --> 00:16:37,520
again and again.

353
00:16:38,720 --> 00:16:41,680
You're calculating full lighting equations still per light.

354
00:16:41,680 --> 00:16:44,680
So that's gonna be an additional cost.

355
00:16:44,680 --> 00:16:48,600
And then some of the additional good looking features

356
00:16:48,600 --> 00:16:52,360
like MSAA translucency blending become a lot difficult.

357
00:16:54,560 --> 00:16:55,920
Okay, so let's take a look.

358
00:16:56,920 --> 00:17:01,920
So this is the G-buffer layout in LUDEworks 1.1.

359
00:17:02,200 --> 00:17:06,400
Some of these images should be now pretty familiar to you

360
00:17:07,600 --> 00:17:10,160
as debug images from your path tracer, for example.

361
00:17:11,320 --> 00:17:15,760
So some components, not necessarily all the components

362
00:17:15,760 --> 00:17:20,680
of a G-buffer are the ambidextrous RGB color,

363
00:17:20,680 --> 00:17:23,400
the depth buffer, which comes second,

364
00:17:23,400 --> 00:17:26,480
the normal buffer, and then the specular filter.

365
00:17:27,920 --> 00:17:32,440
These four combined can give you a diffuse lighting

366
00:17:32,440 --> 00:17:35,360
situation and a specular lighting situation,

367
00:17:35,360 --> 00:17:39,240
which if combined, give you the final image, okay?

368
00:17:40,360 --> 00:17:44,680
So what we're essentially doing is from the Python

369
00:17:44,680 --> 00:17:47,080
that we saw last time, okay?

370
00:17:47,080 --> 00:17:49,400
We're not rendering the frame buffer to the screen,

371
00:17:49,400 --> 00:17:52,560
but really rendering frame buffer to textures.

372
00:17:52,560 --> 00:17:55,720
One of those textures is an RGB texture,

373
00:17:55,720 --> 00:17:56,960
but we don't do any lighting.

374
00:17:56,960 --> 00:17:59,040
We just take the RGB and store it.

375
00:17:59,040 --> 00:18:01,520
So you get the RGB colors

376
00:18:01,520 --> 00:18:04,320
for the visible parts of the scene only.

377
00:18:04,320 --> 00:18:06,200
There may be a lot of stuff in the background.

378
00:18:06,200 --> 00:18:08,500
Don't really care about this after this point.

379
00:18:09,720 --> 00:18:13,640
Similarly, we get the depth buffer, store it in a texture,

380
00:18:13,640 --> 00:18:16,160
take all the normal, store it in a texture,

381
00:18:16,160 --> 00:18:18,600
and then specular factor and store it in texture.

382
00:18:19,600 --> 00:18:23,640
Now, if you think about diffuse lighting,

383
00:18:23,640 --> 00:18:25,640
what was the diffuse lighting equation roughly?

384
00:18:25,640 --> 00:18:28,120
It was something like direction of light,

385
00:18:28,120 --> 00:18:30,600
normal, do a dot product, right?

386
00:18:30,600 --> 00:18:33,920
So if you take the albedo, you take the normal,

387
00:18:33,920 --> 00:18:36,920
and you know where the lights are, you get diffuse lighting.

388
00:18:38,120 --> 00:18:41,080
You can take albedo, normal, specular factor,

389
00:18:41,080 --> 00:18:43,840
you get specular reflection, right?

390
00:18:43,840 --> 00:18:46,800
So that's the kind of process where you're not necessarily

391
00:18:46,800 --> 00:18:48,720
doing it in a single pass,

392
00:18:48,720 --> 00:18:50,920
but you're storing this information

393
00:18:50,920 --> 00:18:52,320
so that along with the lighting,

394
00:18:52,320 --> 00:18:55,880
you can generate the lighting components of the scenes.

395
00:18:57,840 --> 00:18:59,440
Let's dive in a little bit more.

396
00:19:00,360 --> 00:19:04,520
So this is how you would essentially store your buffers.

397
00:19:06,160 --> 00:19:07,880
And I want you to pay attention to this part

398
00:19:07,880 --> 00:19:11,120
because this is something you're gonna do in project four,

399
00:19:11,120 --> 00:19:12,880
not necessarily in real-time rendering,

400
00:19:12,880 --> 00:19:14,920
but in path tracer denoising.

401
00:19:17,280 --> 00:19:22,200
So these images essentially get stored like this.

402
00:19:22,200 --> 00:19:25,720
The RGB color gets stored as an RGBA value.

403
00:19:26,600 --> 00:19:29,440
That is a 24-bit component.

404
00:19:29,440 --> 00:19:31,160
Again, you don't need 32 bits.

405
00:19:31,160 --> 00:19:32,440
You don't need that much precision.

406
00:19:32,440 --> 00:19:34,080
So 24 bits is good enough.

407
00:19:35,240 --> 00:19:38,480
And we'll see how we may or may not use the eight bits

408
00:19:38,480 --> 00:19:40,840
out of this later on.

409
00:19:40,840 --> 00:19:42,480
And then you may store the normal,

410
00:19:42,480 --> 00:19:44,560
which can be either 32 or 64 bit,

411
00:19:44,560 --> 00:19:46,640
depending on the precision you want.

412
00:19:47,480 --> 00:19:48,320
Look at this.

413
00:19:48,320 --> 00:19:49,840
We also store a specular factor here.

414
00:19:49,840 --> 00:19:51,640
We pack it up essentially.

415
00:19:51,640 --> 00:19:55,200
Instead of just having three values that add up to 24 bits,

416
00:19:55,200 --> 00:19:57,160
we also throw in a specular factor

417
00:19:57,160 --> 00:20:01,080
that can pack it up nicely into 32 bits.

418
00:20:01,080 --> 00:20:03,400
Remember how we said caching is important

419
00:20:03,400 --> 00:20:06,920
and reading in 32 bits will be important

420
00:20:06,920 --> 00:20:09,480
and 128 bits will be important?

421
00:20:09,480 --> 00:20:11,680
This is why you have packing here

422
00:20:11,680 --> 00:20:15,080
because even though you can store three numbers, no problem.

423
00:20:15,080 --> 00:20:16,920
Storing it as four numbers is just better

424
00:20:16,920 --> 00:20:19,480
because you'll use the specular factor anyway,

425
00:20:19,480 --> 00:20:22,080
multiple times, and it kind of comes for free.

426
00:20:23,560 --> 00:20:24,640
Okay.

427
00:20:24,640 --> 00:20:26,800
So let's take an example from Killzone 2.

428
00:20:27,800 --> 00:20:30,000
So this is the target image you want, right?

429
00:20:31,000 --> 00:20:32,680
What are some of the lighting effects

430
00:20:32,680 --> 00:20:34,720
or material effects that we see in this?

431
00:20:37,600 --> 00:20:39,600
You guys should be pros at this by now.

432
00:20:39,600 --> 00:20:40,440
Okay.

433
00:20:44,800 --> 00:20:49,800
So I'm sure there's something called mapping and texture.

434
00:20:53,920 --> 00:20:55,920
Textures serve as the albedo

435
00:20:57,080 --> 00:20:59,520
on which the loose lighting is applied.

436
00:20:59,520 --> 00:21:01,880
Let's see, a lot of specular stuff.

437
00:21:01,880 --> 00:21:03,840
There's shadow as well.

438
00:21:03,840 --> 00:21:05,360
Yeah, shadow is good.

439
00:21:05,360 --> 00:21:08,640
So, and there's a motion blur.

440
00:21:08,680 --> 00:21:11,120
There's definitely motion blur here on this guy.

441
00:21:12,080 --> 00:21:14,120
Maybe a little bit on the gun too.

442
00:21:14,120 --> 00:21:14,960
What else?

443
00:21:20,160 --> 00:21:21,560
Amplitude, yes.

444
00:21:21,560 --> 00:21:25,800
If you look at like that, that is amplitude.

445
00:21:25,800 --> 00:21:26,640
What else?

446
00:21:35,520 --> 00:21:36,360
Sorry?

447
00:21:37,320 --> 00:21:38,640
Depth of view, yeah.

448
00:21:38,640 --> 00:21:41,560
Depth of view, yeah, depth of view.

449
00:21:41,560 --> 00:21:42,720
Depth of view.

450
00:21:48,640 --> 00:21:52,840
Yeah, so probably this part is all normal map.

451
00:21:52,840 --> 00:21:53,680
What else?

452
00:21:57,480 --> 00:21:58,920
I mean, some of the basics,

453
00:21:58,920 --> 00:22:01,120
we have to count some of the basic stuff, right?

454
00:22:01,120 --> 00:22:03,200
Walls are probably all diffused,

455
00:22:03,200 --> 00:22:04,560
even if we don't count it.

456
00:22:07,360 --> 00:22:08,480
What is this here?

457
00:22:08,480 --> 00:22:09,320
On the bullets.

458
00:22:10,720 --> 00:22:11,560
Specular.

459
00:22:12,680 --> 00:22:14,640
That's all the buttons here.

460
00:22:14,640 --> 00:22:17,680
I don't think we have any soft surface scattering,

461
00:22:17,680 --> 00:22:20,920
not required for real-time rendering.

462
00:22:22,960 --> 00:22:24,960
Some reflections going on here.

463
00:22:27,840 --> 00:22:30,640
Yeah, shoulder pad is the perfect specular, right?

464
00:22:30,640 --> 00:22:33,800
I don't see too much transparency or translucency here.

465
00:22:34,800 --> 00:22:37,080
But yeah, okay, let's figure it out.

466
00:22:37,080 --> 00:22:40,560
So we figured out all the effects we need, right?

467
00:22:40,560 --> 00:22:43,560
We need our motion blur, we need depth of field,

468
00:22:43,560 --> 00:22:45,360
we need the specular diffused,

469
00:22:46,360 --> 00:22:48,680
we need some normal mapping and bump mapping,

470
00:22:50,480 --> 00:22:53,400
some, you know, amplitude and textures in the background.

471
00:22:53,400 --> 00:22:56,680
So let's take a look at how the scene is now built up

472
00:22:56,680 --> 00:22:58,920
using deferred shading pipeline.

473
00:23:00,160 --> 00:23:01,000
All right.

474
00:23:01,000 --> 00:23:02,840
The first thing we do in the scene,

475
00:23:02,840 --> 00:23:04,200
or pretty much any pipeline,

476
00:23:04,200 --> 00:23:06,600
is generate the depth map, okay?

477
00:23:06,600 --> 00:23:08,200
So this is the depth map for the scene.

478
00:23:08,200 --> 00:23:11,600
You can kind of make out that that is the back wall,

479
00:23:11,600 --> 00:23:14,720
that is something in front of it, and so on, right?

480
00:23:14,720 --> 00:23:16,880
And then this is the closest.

481
00:23:16,880 --> 00:23:20,400
Remember, depth map has zeros the closest to the camera,

482
00:23:20,400 --> 00:23:22,760
and one is the furthest away from the camera.

483
00:23:22,760 --> 00:23:26,000
That's why whites are further away and blacks are closer.

484
00:23:26,000 --> 00:23:26,840
Okay?

485
00:23:27,960 --> 00:23:31,920
The next thing we do is do view space normals, okay?

486
00:23:31,920 --> 00:23:33,760
Why do we do view space normals?

487
00:23:35,200 --> 00:23:36,880
These are not world space normals.

488
00:23:40,360 --> 00:23:42,200
Why are we doing view space normals?

489
00:23:44,480 --> 00:23:47,760
Yeah, reflections and specular will use view space normals.

490
00:23:47,760 --> 00:23:49,720
They don't need to use world space normals,

491
00:23:49,720 --> 00:23:52,280
because then if we have view space normals,

492
00:23:52,280 --> 00:23:55,160
we can do it in the fragment shader, or in screen space.

493
00:23:55,160 --> 00:23:57,080
We don't have to do it in world space,

494
00:23:57,080 --> 00:23:59,680
saving ourselves some transformations.

495
00:24:00,680 --> 00:24:01,880
Okay.

496
00:24:01,880 --> 00:24:03,160
Then we have specular.

497
00:24:03,160 --> 00:24:05,600
Now you see how much specular there is in the scene.

498
00:24:05,600 --> 00:24:07,520
We counted the bullets, so the bullets are here.

499
00:24:07,520 --> 00:24:09,120
We definitely counted that,

500
00:24:09,120 --> 00:24:11,080
but look at how much more specular there is

501
00:24:11,080 --> 00:24:13,520
that we didn't necessarily see.

502
00:24:13,520 --> 00:24:16,200
We said shoulder pads were partially specular.

503
00:24:16,200 --> 00:24:17,480
His glasses are specular.

504
00:24:17,480 --> 00:24:18,680
Look at the eyes.

505
00:24:18,680 --> 00:24:22,200
Eyes definitely seem to be specular in real-time rendering.

506
00:24:22,200 --> 00:24:24,840
So yeah, a lot more specular than we realized.

507
00:24:25,840 --> 00:24:30,840
Then we have a specular roughness factor, or a power,

508
00:24:31,840 --> 00:24:36,840
where the whites essentially are non-specular,

509
00:24:37,160 --> 00:24:42,160
and then this applies a power to how to increase that,

510
00:24:42,280 --> 00:24:44,120
essentially, that specular component.

511
00:24:46,520 --> 00:24:48,440
Then we have a motion vector.

512
00:24:48,440 --> 00:24:50,200
So again, this is in screen space.

513
00:24:50,200 --> 00:24:52,480
It's not in world space.

514
00:24:53,440 --> 00:24:56,680
So we said that the gun has some motion blur,

515
00:24:56,680 --> 00:24:58,920
and this guy has some motion blur, right?

516
00:24:58,920 --> 00:25:01,640
So we're generating an image for that.

517
00:25:01,640 --> 00:25:03,320
This is like optical flow.

518
00:25:05,000 --> 00:25:06,440
What do you mean by optical flow?

519
00:25:06,440 --> 00:25:09,800
Optical flow is usually you capture the real world,

520
00:25:09,800 --> 00:25:12,480
and then you try to visualize it, right?

521
00:25:12,480 --> 00:25:13,920
It's not like in computer vision,

522
00:25:13,920 --> 00:25:17,080
like optical flow is like within two images, right?

523
00:25:17,080 --> 00:25:18,400
You identify two-

524
00:25:18,400 --> 00:25:19,240
Points.

525
00:25:20,080 --> 00:25:24,680
T-shirts, and then like the directional vector of that.

526
00:25:24,680 --> 00:25:27,120
This, or is this something that looks the other way?

527
00:25:27,120 --> 00:25:29,960
This is what you're doing in your projects.

528
00:25:29,960 --> 00:25:34,960
This is literally knowing the velocity of this guy

529
00:25:34,960 --> 00:25:36,000
that we are generating,

530
00:25:36,000 --> 00:25:39,880
how much this person is gonna move between two frames.

531
00:25:39,880 --> 00:25:41,520
So that's how you get the motion.

532
00:25:42,360 --> 00:25:43,200
Okay.

533
00:25:43,200 --> 00:25:46,160
So we generate the 2D motion vector, okay?

534
00:25:46,160 --> 00:25:48,720
So that's gonna give us the motion blur part of it.

535
00:25:49,720 --> 00:25:52,840
Then one of the most basic things,

536
00:25:52,840 --> 00:25:54,160
we generate the albedo.

537
00:25:54,160 --> 00:25:58,560
So now you see without any lighting effects,

538
00:25:58,560 --> 00:26:00,280
what that color looks like.

539
00:26:00,280 --> 00:26:03,720
The window almost looked like a grill, right?

540
00:26:03,720 --> 00:26:06,200
It didn't look like there were windows in there.

541
00:26:06,200 --> 00:26:08,000
If I go to the other side and see.

542
00:26:08,600 --> 00:26:09,440
All right.

543
00:26:09,440 --> 00:26:10,280
So look at this.

544
00:26:10,280 --> 00:26:13,160
There's no reflection here whatsoever, right?

545
00:26:13,160 --> 00:26:15,000
It just looks like bars.

546
00:26:15,000 --> 00:26:16,920
But if we look at the specular map,

547
00:26:18,160 --> 00:26:19,000
the specular map,

548
00:26:19,000 --> 00:26:21,440
look at how the windows are highlighted

549
00:26:21,440 --> 00:26:24,000
as being specular, right?

550
00:26:24,000 --> 00:26:26,560
And then if we go to the albedo without lighting,

551
00:26:28,120 --> 00:26:29,920
now we see the windows come out.

552
00:26:29,920 --> 00:26:31,760
So this is the albedo, right?

553
00:26:31,760 --> 00:26:33,080
So this is the albedo.

554
00:26:33,080 --> 00:26:33,920
So this is the albedo.

555
00:26:33,920 --> 00:26:34,760
So this is the albedo.

556
00:26:34,760 --> 00:26:35,600
So this is the albedo.

557
00:26:36,600 --> 00:26:38,480
Now we see the windows come out.

558
00:26:38,480 --> 00:26:40,320
The glass of the windows come out.

559
00:26:40,320 --> 00:26:42,200
So that's why albedo becomes important

560
00:26:42,200 --> 00:26:44,560
because it gives you a sense of what the scene is like

561
00:26:44,560 --> 00:26:46,440
without any lighting.

562
00:26:46,440 --> 00:26:47,920
Also look at the bullets.

563
00:26:48,800 --> 00:26:50,800
No specular there, it's just yellow.

564
00:26:50,800 --> 00:26:52,760
It's almost flat shaded, right?

565
00:26:54,400 --> 00:26:56,880
And the scene also looks a lot more lit up.

566
00:26:58,280 --> 00:27:00,240
The background is a lot more visible.

567
00:27:00,240 --> 00:27:01,960
There seems to be a lot more light in the scene

568
00:27:01,960 --> 00:27:04,200
because technically we are not using light.

569
00:27:04,200 --> 00:27:05,360
It's all albedo.

570
00:27:06,600 --> 00:27:07,440
All right.

571
00:27:09,560 --> 00:27:12,360
But we get the deferred composition

572
00:27:12,360 --> 00:27:15,360
where we are bringing in some of those lighting things.

573
00:27:15,360 --> 00:27:17,920
You take the albedo, you take the normal maps,

574
00:27:17,920 --> 00:27:18,920
the specular maps,

575
00:27:18,920 --> 00:27:21,120
and now you're building the scene from that.

576
00:27:23,120 --> 00:27:24,240
No motion blur in this.

577
00:27:24,240 --> 00:27:27,200
We haven't put that in yet.

578
00:27:28,200 --> 00:27:31,480
Now, if we add the motion blur, the depth of field,

579
00:27:31,480 --> 00:27:33,280
again, this is all post-processing.

580
00:27:33,280 --> 00:27:35,720
Post-processing is in screen space.

581
00:27:35,720 --> 00:27:38,440
So everything that we spoke about was screen space

582
00:27:38,440 --> 00:27:39,360
now gets added on.

583
00:27:39,360 --> 00:27:41,960
So we have depth of field, bloom, motion blur,

584
00:27:41,960 --> 00:27:45,520
colorization, all into this.

585
00:27:45,520 --> 00:27:49,640
So that's why when I say doing something in screen space,

586
00:27:49,640 --> 00:27:51,960
that's what allows you to do it in post-processing

587
00:27:51,960 --> 00:27:52,880
as a fragment shader.

588
00:27:52,880 --> 00:27:55,040
You don't have to run a full pass for it.

589
00:27:55,040 --> 00:27:57,840
You can just do it in a fragment shader.

590
00:27:57,840 --> 00:28:00,720
So any questions on how the scene got built

591
00:28:00,760 --> 00:28:03,360
using the different passes?

592
00:28:03,360 --> 00:28:07,280
So what's happening in each of these frames,

593
00:28:07,280 --> 00:28:09,840
so I'll come back to albedo,

594
00:28:09,840 --> 00:28:14,840
is you're not in the rasterization pipeline.

595
00:28:15,160 --> 00:28:17,680
The pipeline itself isn't necessarily changing.

596
00:28:17,680 --> 00:28:20,200
The single pass pipeline that we have isn't changing.

597
00:28:20,200 --> 00:28:23,560
What we are changing is that in each pass,

598
00:28:23,560 --> 00:28:26,680
we output one of these debug images

599
00:28:26,680 --> 00:28:30,120
or intermediate images as a texture.

600
00:28:30,120 --> 00:28:32,920
And then we run the lighting pass,

601
00:28:32,920 --> 00:28:34,720
which takes all the lights into account

602
00:28:34,720 --> 00:28:37,960
and these textures, doesn't take geometry into account.

603
00:28:37,960 --> 00:28:41,040
Okay, the geometry is gone at that point.

604
00:28:41,040 --> 00:28:44,280
It only takes the depth buffer, the albedo texture,

605
00:28:44,280 --> 00:28:46,760
the normals, the screen space texture,

606
00:28:46,760 --> 00:28:50,160
all of those into account and build the lighting from that.

607
00:28:50,160 --> 00:28:54,800
So that's how you separate the lighting from the geometry.

608
00:28:54,800 --> 00:28:56,640
So now the lighting only works

609
00:28:56,640 --> 00:28:58,680
on what's visible in your scene.

610
00:29:00,960 --> 00:29:02,680
So any questions on this?

611
00:29:02,680 --> 00:29:04,320
Any questions on how we got here?

612
00:29:08,000 --> 00:29:09,560
Because this is kind of what you're gonna do

613
00:29:09,560 --> 00:29:10,840
in the denoiser as well.

614
00:29:10,840 --> 00:29:12,360
You're gonna take your G buffer

615
00:29:12,360 --> 00:29:14,560
and then run that through a bunch of things.

616
00:29:17,520 --> 00:29:18,360
Yeah, Ed?

617
00:29:18,360 --> 00:29:23,360
So with the, we can think of the depth map

618
00:29:23,600 --> 00:29:27,280
as sort of like a geometric hole, I guess, right?

619
00:29:27,280 --> 00:29:30,280
In terms of just how far, how close everything is to it.

620
00:29:31,600 --> 00:29:36,600
So that instead of doing like a break intersect, right?

621
00:29:37,680 --> 00:29:41,400
We just sample screen space for the distance.

622
00:29:41,400 --> 00:29:43,320
Yeah, exactly.

623
00:29:43,320 --> 00:29:48,320
So if you had to answer the question for each pixel,

624
00:29:49,800 --> 00:29:53,160
what is the depth of that pixel in the 3D world?

625
00:29:53,160 --> 00:29:55,000
Your depth map answers that question.

626
00:29:55,840 --> 00:30:00,840
So it's the closest point to what's visible to you.

627
00:30:01,200 --> 00:30:03,360
So from my point of view,

628
00:30:03,360 --> 00:30:07,280
if I wanted something over there that's closer,

629
00:30:07,280 --> 00:30:08,400
this is gonna be the back wall.

630
00:30:08,400 --> 00:30:11,480
If I'm looking down here, it's gonna be the stable, right?

631
00:30:11,480 --> 00:30:13,440
So you're only looking for the closest point

632
00:30:13,440 --> 00:30:14,520
in the depth buffer.

633
00:30:15,440 --> 00:30:17,760
You would get this depth buffer

634
00:30:17,760 --> 00:30:22,480
by basically getting all the per pixel T values

635
00:30:22,480 --> 00:30:24,400
of the frame pass from the camera?

636
00:30:24,400 --> 00:30:25,240
No, not at all.

637
00:30:25,240 --> 00:30:26,080
You would rasterize the scene

638
00:30:26,080 --> 00:30:27,720
and store it in the depth buffer.

639
00:30:28,920 --> 00:30:32,120
You're not doing ray casting at all.

640
00:30:32,120 --> 00:30:33,440
You're doing only rasterization.

641
00:30:33,440 --> 00:30:34,840
This is real-time rendering.

642
00:30:37,040 --> 00:30:40,200
So if you think about our last lecture,

643
00:30:40,200 --> 00:30:43,240
when we do the rasterization pipeline,

644
00:30:43,240 --> 00:30:44,880
one of the goals of rasterization

645
00:30:44,880 --> 00:30:47,080
is to figure out what's visible.

646
00:30:47,080 --> 00:30:49,080
What's the first thing that is visible?

647
00:30:49,080 --> 00:30:51,200
Remember that two triangles that we had

648
00:30:51,200 --> 00:30:53,240
when we tried to figure it out

649
00:30:53,240 --> 00:30:55,400
through flood fill or scanline algorithms

650
00:30:55,400 --> 00:30:57,840
about how we figured out which triangle

651
00:30:57,840 --> 00:31:00,160
is ahead of which triangle?

652
00:31:00,160 --> 00:31:02,760
That is kind of what the rasterization pipeline is doing.

653
00:31:02,760 --> 00:31:05,520
And one of the outputs of rasterization pipeline

654
00:31:05,520 --> 00:31:06,720
is the depth buffer.

655
00:31:10,080 --> 00:31:11,480
Any other questions on this?

656
00:31:15,760 --> 00:31:18,600
Okay, so let's take a look at how...

657
00:31:18,600 --> 00:31:21,080
Now, we have all of these images, right?

658
00:31:21,960 --> 00:31:23,160
We've got so many textures.

659
00:31:23,160 --> 00:31:24,480
We have to store them somewhere

660
00:31:24,480 --> 00:31:26,760
because you're not gonna store a texture

661
00:31:26,760 --> 00:31:27,880
and run the lighting pass.

662
00:31:27,880 --> 00:31:29,520
You have to run all of these textures.

663
00:31:29,520 --> 00:31:32,040
You have to have all of those textures saved

664
00:31:32,040 --> 00:31:34,360
before you can run the lighting pass.

665
00:31:34,360 --> 00:31:35,720
So to save that,

666
00:31:35,720 --> 00:31:39,080
we store it in what we call the geometry buffer.

667
00:31:39,080 --> 00:31:40,880
And this is what the geometry buffer

668
00:31:40,880 --> 00:31:43,160
for Killzone 2 looks like, okay?

669
00:31:43,160 --> 00:31:44,360
So let's go through it.

670
00:31:45,360 --> 00:31:47,160
So first, you had...

671
00:31:49,280 --> 00:31:53,680
First see that these are all 32 bits, okay?

672
00:31:53,680 --> 00:31:55,920
That's the first thing I want you to notice.

673
00:31:57,920 --> 00:32:00,720
So the first thing we have in our first buffer

674
00:32:00,720 --> 00:32:05,160
is the 24-bit per pixel floating point depth.

675
00:32:05,160 --> 00:32:07,560
We don't need 32 bits, 24-bit is good enough.

676
00:32:07,560 --> 00:32:09,560
So we'll store 24 bits.

677
00:32:09,560 --> 00:32:11,720
Now, we have eight bits left.

678
00:32:12,360 --> 00:32:15,880
So we'll store a boolean for the stencil.

679
00:32:15,880 --> 00:32:19,680
You know, we can have different textures, right?

680
00:32:19,680 --> 00:32:22,040
And not every texture has to cover everything.

681
00:32:22,040 --> 00:32:27,040
So we store the stencil as an alpha or a boolean.

682
00:32:28,520 --> 00:32:31,080
We'll store a lighting accumulation RGB

683
00:32:31,080 --> 00:32:32,600
along with its intensity.

684
00:32:33,800 --> 00:32:36,920
We only store two normals at 16 bits each.

685
00:32:36,920 --> 00:32:37,880
Why?

686
00:32:37,880 --> 00:32:39,640
Why are we storing normal XYZ?

687
00:32:42,400 --> 00:32:44,320
Oh, this is for normal.

688
00:32:54,320 --> 00:32:56,600
Why don't we store normal Z?

689
00:33:01,720 --> 00:33:03,840
Normal Z can be computed by normal X and normal Y

690
00:33:03,840 --> 00:33:05,040
using a cross pattern.

691
00:33:07,120 --> 00:33:08,680
So we need to store a normal Z.

692
00:33:08,680 --> 00:33:10,360
And a cross pattern.

693
00:33:11,520 --> 00:33:13,080
So we don't need to store that.

694
00:33:16,280 --> 00:33:18,640
Then we have a few other vectors.

695
00:33:18,640 --> 00:33:20,320
So we have motion vector X and Y.

696
00:33:20,320 --> 00:33:21,600
So in both directions,

697
00:33:21,600 --> 00:33:24,840
because it's screen-based, you only need X and Y.

698
00:33:24,840 --> 00:33:26,800
We have specular power and specular intensity,

699
00:33:26,800 --> 00:33:29,360
two things that we saw above before.

700
00:33:29,360 --> 00:33:32,600
The last one is the diffuse albedos RGB.

701
00:33:32,600 --> 00:33:34,400
And then you have some occlusion

702
00:33:34,400 --> 00:33:37,920
from the sun lighting or the ambient lighting.

703
00:33:37,920 --> 00:33:42,240
So that allows you to build what is known as the G-buffer.

704
00:33:42,240 --> 00:33:44,720
And you take all of these vectors

705
00:33:44,720 --> 00:33:47,960
and then run the lighting computation

706
00:33:47,960 --> 00:33:50,120
for how you're going to build a scene.

707
00:33:50,120 --> 00:33:52,400
And I haven't told you how to do the lighting.

708
00:33:52,400 --> 00:33:55,640
I've only showed you how to do the G-buffer so far.

709
00:33:55,640 --> 00:33:56,560
Lighting will come next.

710
00:33:56,560 --> 00:33:59,480
I want to make sure that all of you understand

711
00:33:59,480 --> 00:34:01,120
how the G-buffer is coming about

712
00:34:02,360 --> 00:34:04,000
and what it's going to be useful.

713
00:34:06,560 --> 00:34:07,800
Any questions on this?

714
00:34:07,920 --> 00:34:08,760
Okay.

715
00:34:11,920 --> 00:34:16,920
So let's take a look at how we take the G-buffer

716
00:34:19,600 --> 00:34:22,200
and then compute the lighting from it.

717
00:34:22,200 --> 00:34:25,080
The one thing I want to highlight is the sun occlusion

718
00:34:25,080 --> 00:34:26,920
is used for shadows here.

719
00:34:26,920 --> 00:34:28,800
That's one thing I forgot to mention.

720
00:34:30,280 --> 00:34:31,840
Okay.

721
00:34:31,840 --> 00:34:33,920
So final call for questions on this.

722
00:34:35,600 --> 00:34:36,440
All right.

723
00:34:36,440 --> 00:34:39,320
So let's see how the G-buffer then gets used in light.

724
00:34:41,200 --> 00:34:42,840
So one of the things we want to do

725
00:34:42,840 --> 00:34:47,000
is understand the geometry for each light.

726
00:34:47,000 --> 00:34:48,160
Okay.

727
00:34:48,160 --> 00:34:50,160
We said before that not every light

728
00:34:50,160 --> 00:34:53,240
affects every object in the scene, even if it's visible.

729
00:34:53,240 --> 00:34:56,400
Not every light is going to affect every object.

730
00:34:56,400 --> 00:35:00,920
So we construct a volume around the light

731
00:35:00,920 --> 00:35:03,440
depending on its power and intensity

732
00:35:03,440 --> 00:35:06,920
about which objects it's going to affect.

733
00:35:06,920 --> 00:35:10,400
And that can be done using a scissor or stencil test.

734
00:35:11,320 --> 00:35:14,840
And if it's a full screen, then you apply the whole thing.

735
00:35:14,840 --> 00:35:18,720
If you want to do it in 3D, you do it as a sphere or a cone

736
00:35:18,720 --> 00:35:20,840
depending on what kind of a light you have.

737
00:35:20,840 --> 00:35:21,680
Okay.

738
00:35:21,680 --> 00:35:24,720
So this example here to our bottom right,

739
00:35:24,720 --> 00:35:27,840
it shows the light, which is in purple

740
00:35:27,840 --> 00:35:31,480
and its field of influence, essentially.

741
00:35:31,480 --> 00:35:33,160
Its sphere of influence.

742
00:35:33,960 --> 00:35:36,120
Let's take this point here.

743
00:35:37,520 --> 00:35:39,560
If our object is in this black space,

744
00:35:39,560 --> 00:35:40,920
this point isn't going to affect that

745
00:35:40,920 --> 00:35:43,400
because it's not powerful enough.

746
00:35:43,400 --> 00:35:48,400
So that's why we say we only need to do every light,

747
00:35:48,640 --> 00:35:51,800
process every light within its sphere of influence only.

748
00:35:52,720 --> 00:35:55,160
So that's the first thing I'm going to do.

749
00:35:55,160 --> 00:35:57,720
This essentially reduces your workload

750
00:35:57,720 --> 00:35:59,480
and improves performance.

751
00:36:00,480 --> 00:36:04,400
From there, you can do additive blending.

752
00:36:04,400 --> 00:36:07,920
So for example, we have these here, right?

753
00:36:07,920 --> 00:36:11,360
And these are just the points that we have.

754
00:36:11,360 --> 00:36:14,640
If you do some overlap on this using additive blending,

755
00:36:14,640 --> 00:36:16,440
you'll see that the bright red parts

756
00:36:16,440 --> 00:36:19,360
are where more lights affect an object

757
00:36:19,360 --> 00:36:22,440
and the darker parts are where no lights affect an object.

758
00:36:22,440 --> 00:36:26,360
So using that, we can accelerate the pipeline as well.

759
00:36:26,800 --> 00:36:29,200
Because now what you can do is,

760
00:36:29,200 --> 00:36:33,040
if you know that this sphere, for example,

761
00:36:33,040 --> 00:36:34,840
only affects this light,

762
00:36:34,840 --> 00:36:38,240
you don't have to render the full scene, right?

763
00:36:38,240 --> 00:36:42,240
You don't have to render like 1920 by 1080,

764
00:36:42,240 --> 00:36:44,400
for example, if that's your scene size.

765
00:36:44,400 --> 00:36:48,160
You only have to pick what's the bounding area for this

766
00:36:48,160 --> 00:36:51,640
in pixel space, in window space,

767
00:36:51,640 --> 00:36:53,280
and you only work on that.

768
00:36:53,280 --> 00:36:54,760
So now you can do that.

769
00:36:54,800 --> 00:36:56,040
You only work on that.

770
00:36:56,040 --> 00:36:58,320
So now you can create parallelism there as well,

771
00:36:58,320 --> 00:37:02,280
where you can run multiple light passes at the same time

772
00:37:02,280 --> 00:37:03,480
in the GPU.

773
00:37:05,200 --> 00:37:06,400
Any questions on this?

774
00:37:09,160 --> 00:37:11,840
So let's take a look at this demo here,

775
00:37:11,840 --> 00:37:14,400
which shows off how that works.

776
00:37:25,440 --> 00:37:26,880
So I'm gonna play this video.

777
00:37:35,760 --> 00:37:38,520
So now you can see how there are lights going around

778
00:37:38,520 --> 00:37:40,640
and this purple light doesn't affect everything.

779
00:37:40,640 --> 00:37:42,800
It just affects, oh, look at the green light there.

780
00:37:42,800 --> 00:37:45,680
It only affects the part that's closed,

781
00:37:45,680 --> 00:37:47,920
but not necessarily this wall on the side.

782
00:37:47,920 --> 00:37:50,400
That's being affected by a different light.

783
00:37:50,400 --> 00:37:52,640
So that's where you can pick and choose

784
00:37:52,640 --> 00:37:55,400
which area of the scene you want to render.

785
00:37:55,400 --> 00:37:58,880
And that's where you can have so many more lights.

786
00:37:58,880 --> 00:38:01,800
If you want to have these many lights

787
00:38:01,800 --> 00:38:03,640
with a simple forward pass rendering,

788
00:38:03,640 --> 00:38:05,600
it would just run too slowly

789
00:38:05,600 --> 00:38:09,040
because you're trying to compute too much at the same time.

790
00:38:12,680 --> 00:38:17,680
So there's a WebGL drop buffers API in WebGL,

791
00:38:18,520 --> 00:38:23,520
and that can also have with the GBuffer.

792
00:38:24,560 --> 00:38:29,560
So when using WebGL drop buffers performance

793
00:38:29,560 --> 00:38:33,440
with this kind of a scene with 25 Stanford dragons,

794
00:38:33,440 --> 00:38:36,320
with the extension, with the drop buffers extension,

795
00:38:36,320 --> 00:38:39,240
you get significantly better performance.

796
00:38:39,240 --> 00:38:41,760
Remember, this is FPS here.

797
00:38:41,760 --> 00:38:44,160
Then you do without that extension.

798
00:38:44,160 --> 00:38:46,240
Okay, there are gonna be graphics extension.

799
00:38:46,240 --> 00:38:49,680
You're gonna come across that will significantly

800
00:38:49,680 --> 00:38:52,920
improve the performance you get or may decrease it.

801
00:38:52,920 --> 00:38:56,600
Similarly, with 25 Stanford dragons,

802
00:38:56,600 --> 00:39:00,560
you're gonna see similar issues as well.

803
00:39:00,560 --> 00:39:05,560
Essentially what it's doing is the drop buffers pass

804
00:39:06,640 --> 00:39:11,640
is helping your fragment shader write multiple textures.

805
00:39:12,640 --> 00:39:17,120
For example, after you do your rasterization,

806
00:39:18,560 --> 00:39:20,240
think about all the textures you can write.

807
00:39:20,240 --> 00:39:22,760
In just one pass, you do the rasterization.

808
00:39:22,760 --> 00:39:24,640
What information do you have at that point?

809
00:39:24,640 --> 00:39:28,120
You have the depth, you have the albedo.

810
00:39:28,120 --> 00:39:33,120
Let's say you have the specular lighting, right?

811
00:39:33,520 --> 00:39:36,800
You can compute all of those and store it in a texture.

812
00:39:36,800 --> 00:39:39,800
So instead of having three different rasterization passes

813
00:39:39,840 --> 00:39:41,760
for each of those,

814
00:39:41,760 --> 00:39:43,920
you can just do all of those in one pass and store it.

815
00:39:43,920 --> 00:39:47,400
So you significantly reduce how many single passes you do

816
00:39:47,400 --> 00:39:49,680
for each one of those intermediate buffers.

817
00:39:50,560 --> 00:39:52,640
So that's what this is trying to explain

818
00:39:52,640 --> 00:39:55,640
that you have to, when using these graphics APIs,

819
00:39:55,640 --> 00:39:59,120
you should always look for extensions and stuff

820
00:39:59,120 --> 00:40:01,120
that can help improve your performance.

821
00:40:04,080 --> 00:40:07,160
So in default shading,

822
00:40:08,000 --> 00:40:13,000
there's a few good parts and a few bad parts.

823
00:40:13,360 --> 00:40:16,720
The good parts are that light management becomes trivial

824
00:40:16,720 --> 00:40:19,960
because light is only working on screen space

825
00:40:19,960 --> 00:40:21,960
in the G-buffer.

826
00:40:21,960 --> 00:40:24,120
You can manage as many lights as you want

827
00:40:24,120 --> 00:40:26,120
without too much complexity.

828
00:40:26,120 --> 00:40:27,800
The shader management is simple,

829
00:40:27,800 --> 00:40:30,360
again, because you're working only on the G-buffer

830
00:40:30,360 --> 00:40:31,800
from a lighting perspective.

831
00:40:32,760 --> 00:40:34,560
There's no overdraw.

832
00:40:34,560 --> 00:40:36,160
There's single pass geometry.

833
00:40:36,160 --> 00:40:39,520
You're not rendering on occluded aspects.

834
00:40:39,520 --> 00:40:42,440
And you can reuse the shadow map for different things.

835
00:40:42,440 --> 00:40:43,440
Now the bad part,

836
00:40:45,120 --> 00:40:47,520
because everything happens through this G-buffer

837
00:40:47,520 --> 00:40:51,200
in screen space, there's no transparency, right?

838
00:40:51,200 --> 00:40:54,080
Those windows weren't transparent when we saw them.

839
00:40:54,080 --> 00:40:56,000
Because if you wanted to do transparency,

840
00:40:56,000 --> 00:40:58,640
now you have to do multi-pass on the objects

841
00:40:58,640 --> 00:41:00,240
and figure out different depths.

842
00:41:00,240 --> 00:41:02,960
Like the depth buffer, for example,

843
00:41:02,960 --> 00:41:04,280
can have only one value.

844
00:41:04,280 --> 00:41:05,440
You can't have two values.

845
00:41:05,720 --> 00:41:07,360
You can't say, I have a window

846
00:41:07,360 --> 00:41:09,040
and I have something behind it.

847
00:41:09,040 --> 00:41:11,280
There's no transparency in the first shading

848
00:41:11,280 --> 00:41:12,760
for that reason.

849
00:41:12,760 --> 00:41:14,720
You have very large frame buffer

850
00:41:14,720 --> 00:41:18,160
because you need to store all of that G-buffer data.

851
00:41:18,160 --> 00:41:20,360
If you need MSA, you need to like four times

852
00:41:20,360 --> 00:41:22,840
or eight times your frame buffer as well.

853
00:41:24,320 --> 00:41:26,240
You can have multiple shading.

854
00:41:26,240 --> 00:41:28,440
If you want to do multiple shading models

855
00:41:28,440 --> 00:41:30,360
with different types of shading,

856
00:41:30,360 --> 00:41:35,160
let's say toon shading and physically-based shading,

857
00:41:35,920 --> 00:41:36,760
that becomes very, very difficult

858
00:41:36,760 --> 00:41:40,120
because you don't have that pipeline anymore.

859
00:41:40,120 --> 00:41:41,560
And you use a lot of bandwidth

860
00:41:41,560 --> 00:41:43,320
because you're reading and writing

861
00:41:43,320 --> 00:41:44,960
through those textures quite a bit.

862
00:41:44,960 --> 00:41:48,480
So you have to make sure that all of your GPU bandwidth

863
00:41:48,480 --> 00:41:49,760
is being used effectively

864
00:41:49,760 --> 00:41:52,600
and you're not hurting yourself because of that.

865
00:41:54,760 --> 00:41:56,960
Any questions on the pros and cons of this?

866
00:41:56,960 --> 00:41:57,800
Okay.

867
00:42:02,840 --> 00:42:06,360
So let's take a look at how do we improve this further?

868
00:42:06,360 --> 00:42:07,200
Okay.

869
00:42:07,200 --> 00:42:09,240
So we have different shading.

870
00:42:09,240 --> 00:42:11,000
It's good, but not perfect.

871
00:42:11,000 --> 00:42:12,440
How do we improve it further?

872
00:42:13,760 --> 00:42:16,240
The first thing you do is,

873
00:42:20,640 --> 00:42:22,320
the first thing you do is you kind of borrow

874
00:42:22,320 --> 00:42:23,520
from matrix multiply.

875
00:42:24,400 --> 00:42:27,960
Remember how in matrix multiply we created tiles

876
00:42:27,960 --> 00:42:31,680
to do one block each and then do other blocks, right?

877
00:42:33,000 --> 00:42:36,160
We're going to divide our screen into two big blocks.

878
00:42:36,160 --> 00:42:38,640
For example, of 16 by 16 pixels.

879
00:42:38,640 --> 00:42:39,480
Okay.

880
00:42:40,520 --> 00:42:44,880
In those, we'll only pick the lights that affect that tile.

881
00:42:46,080 --> 00:42:48,640
So now not all lights are affecting every tile.

882
00:42:48,640 --> 00:42:49,720
You can optimize it.

883
00:42:51,000 --> 00:42:53,440
To do that, you can do it in the compute chain

884
00:42:54,240 --> 00:42:55,080
or you can do it on the CPU,

885
00:42:55,080 --> 00:42:56,880
but compute shader is going to be faster

886
00:42:56,880 --> 00:42:59,400
to compute which lights affect which tiles.

887
00:43:00,400 --> 00:43:02,880
And then you can do a light accumulation pass

888
00:43:02,880 --> 00:43:05,280
to read on the GBuffer only once

889
00:43:05,280 --> 00:43:08,400
and then all use the light tile info

890
00:43:08,400 --> 00:43:10,840
to find which light is affecting which pixel.

891
00:43:10,840 --> 00:43:12,840
So let's dive into this a little.

892
00:43:12,840 --> 00:43:14,480
So we have the scene here, right?

893
00:43:16,120 --> 00:43:17,760
This would be how the tiles look.

894
00:43:19,000 --> 00:43:20,760
So I'll switch back and forth.

895
00:43:21,760 --> 00:43:24,520
So you see how there's a big empty area here.

896
00:43:25,640 --> 00:43:27,760
So that's kind of seen here.

897
00:43:27,760 --> 00:43:30,520
But what I want you to notice is these squares.

898
00:43:30,520 --> 00:43:33,000
This is not a low resolution image.

899
00:43:33,000 --> 00:43:35,200
It's the same resolution image

900
00:43:35,200 --> 00:43:39,160
that is showing the different tiles in the image, right?

901
00:43:39,160 --> 00:43:40,680
We said 16 by 16 tiles.

902
00:43:40,680 --> 00:43:45,240
We are taking this image here and creating those tiles

903
00:43:45,240 --> 00:43:47,680
just like we did in matrix multiply.

904
00:43:48,000 --> 00:43:53,000
So each one of these is a tile within the image

905
00:43:53,920 --> 00:43:58,920
that you are using to compute how many lights there are.

906
00:44:00,040 --> 00:44:04,280
So in this particular image, going from here to here,

907
00:44:09,440 --> 00:44:14,440
here, the white, this is not a depth buffer, by the way.

908
00:44:14,800 --> 00:44:18,120
In this, white is representing more lights

909
00:44:18,120 --> 00:44:21,280
and black is representing less lights.

910
00:44:21,280 --> 00:44:22,680
So pay attention to this.

911
00:44:22,680 --> 00:44:24,400
Which is the white?

912
00:44:24,400 --> 00:44:27,600
Maybe this, this line here,

913
00:44:27,600 --> 00:44:30,120
black area that goes inside, right?

914
00:44:30,120 --> 00:44:31,560
So let's switch back.

915
00:44:31,560 --> 00:44:32,400
Pay attention.

916
00:44:34,400 --> 00:44:35,240
Does it match?

917
00:44:35,240 --> 00:44:38,200
So we did this, this has more lights

918
00:44:38,200 --> 00:44:40,240
and there's lights here, right?

919
00:44:41,160 --> 00:44:42,200
Now we'll switch back.

920
00:44:43,200 --> 00:44:47,760
You can see that, right?

921
00:44:47,760 --> 00:44:50,480
So that's what this image is showing

922
00:44:50,480 --> 00:44:53,080
is how many lights are covering each tile.

923
00:44:54,400 --> 00:44:59,280
And based on that, now you can choose which tiles

924
00:44:59,280 --> 00:45:04,280
have which lights and then render those together

925
00:45:04,600 --> 00:45:05,960
to improve performance.

926
00:45:07,400 --> 00:45:10,640
So to look at this, again,

927
00:45:10,640 --> 00:45:12,240
performance matters everywhere.

928
00:45:13,160 --> 00:45:16,440
We take this scene with number of lights

929
00:45:16,440 --> 00:45:19,520
and see how, when you go from a very small number of lights

930
00:45:19,520 --> 00:45:21,800
to a very large number of lights,

931
00:45:21,800 --> 00:45:23,920
using tile-based shading

932
00:45:23,920 --> 00:45:26,000
significantly improves your performance.

933
00:45:27,080 --> 00:45:27,920
Why is that?

934
00:45:29,120 --> 00:45:32,600
Because when you have like, let's say a thousand lights,

935
00:45:32,600 --> 00:45:34,280
if you did non-tile-based shading,

936
00:45:34,280 --> 00:45:39,280
you're trying to compute the effect of any light

937
00:45:40,160 --> 00:45:43,920
in a given area to the entire image, right?

938
00:45:43,920 --> 00:45:45,160
Whereas in tile-based shading,

939
00:45:45,160 --> 00:45:46,960
you're computing which part of the image

940
00:45:46,960 --> 00:45:48,240
is affected by that light.

941
00:45:48,240 --> 00:45:51,560
And only those tiles are computed for each of them.

942
00:45:51,560 --> 00:45:54,280
So it significantly improves the performance.

943
00:45:54,280 --> 00:45:56,520
Similarly, for tile science,

944
00:45:56,520 --> 00:46:00,240
the smaller your tile, the more tiles you have.

945
00:46:00,240 --> 00:46:04,160
So you may not get adequate work done

946
00:46:04,160 --> 00:46:05,600
if your tile is too big.

947
00:46:05,600 --> 00:46:08,400
Then too many lights are affecting your each tile

948
00:46:08,400 --> 00:46:10,160
and you won't get the performance.

949
00:46:10,160 --> 00:46:13,680
So choosing a 16 by 16 or 32 by 32 tile

950
00:46:13,680 --> 00:46:16,560
usually gives you good performance.

951
00:46:16,560 --> 00:46:20,360
And this is something you've seen in,

952
00:46:20,360 --> 00:46:22,640
let's say your reduction and scans

953
00:46:22,640 --> 00:46:26,520
where you've chosen different block size, right?

954
00:46:26,520 --> 00:46:28,320
So this is exactly similar to that,

955
00:46:28,320 --> 00:46:30,400
except in a rendering concept

956
00:46:30,400 --> 00:46:32,240
rather than in a compute concept.

957
00:46:35,120 --> 00:46:36,560
Any questions on this slide?

958
00:46:38,720 --> 00:46:39,560
Okay.

959
00:46:43,120 --> 00:46:44,800
So there are a bunch of references here

960
00:46:44,800 --> 00:46:47,680
that we've used for these slides.

961
00:46:47,680 --> 00:46:48,720
Feel free to check them out.

962
00:46:48,720 --> 00:46:50,280
There's a bunch of demos as well

963
00:46:51,400 --> 00:46:52,840
that you can play around with

964
00:46:52,840 --> 00:46:55,040
to understand deferred rendering a lot more.

965
00:46:56,000 --> 00:46:56,840
Okay.

966
00:46:58,200 --> 00:46:59,680
The other thing I want to show

967
00:46:59,680 --> 00:47:04,680
is optimizing how we do backfaces and stuff.

968
00:47:05,680 --> 00:47:10,680
So if you flip the depth stress to greater,

969
00:47:10,680 --> 00:47:13,160
so I said zero is close to the camera

970
00:47:13,160 --> 00:47:15,440
and one is further away from the camera, right?

971
00:47:15,440 --> 00:47:16,880
If you flip that,

972
00:47:16,880 --> 00:47:19,720
now you can get what's backface essentially.

973
00:47:19,720 --> 00:47:21,960
So it's kind of like front face color.

974
00:47:21,960 --> 00:47:23,760
So you hide the front faces

975
00:47:23,760 --> 00:47:25,800
and you see what the backfaces are.

976
00:47:25,800 --> 00:47:28,360
So you can optimize that further as well.

977
00:47:28,360 --> 00:47:30,720
So let me open a demo for this.

978
00:47:35,520 --> 00:47:37,680
So look at this, lots of lights, right?

979
00:47:37,680 --> 00:47:40,040
All the spheres roaming around our lights.

980
00:47:40,040 --> 00:47:41,320
We have 50 lights in the scene.

981
00:47:41,320 --> 00:47:43,400
I'm going to increase it to a hundred.

982
00:47:43,400 --> 00:47:44,920
Okay.

983
00:47:44,920 --> 00:47:46,400
And see how,

984
00:47:47,960 --> 00:47:49,400
while this is the final image,

985
00:47:49,400 --> 00:47:51,480
let's go through each of these stages.

986
00:47:51,480 --> 00:47:53,720
So I'm only going to do color.

987
00:47:55,640 --> 00:47:59,440
Now, why did the spheres change into these cone type things?

988
00:48:00,800 --> 00:48:02,440
So let me go back to the final.

989
00:48:03,440 --> 00:48:05,720
So these spheres are around

990
00:48:05,720 --> 00:48:07,920
and then we have some cones around it, right?

991
00:48:07,920 --> 00:48:11,400
So those are the cones that we see here in the color.

992
00:48:11,400 --> 00:48:14,080
So white means there is some color,

993
00:48:14,080 --> 00:48:16,520
black means there is no color or it's an object.

994
00:48:17,680 --> 00:48:20,880
We see the normals much more clearly here, right?

995
00:48:22,280 --> 00:48:24,440
We can do a depth buffer.

996
00:48:24,440 --> 00:48:26,800
White is furthest away, black is closest.

997
00:48:26,800 --> 00:48:29,720
So as these cones come close to the camera,

998
00:48:29,720 --> 00:48:30,760
they'll become black.

999
00:48:32,720 --> 00:48:34,440
Then we can do a deferred one.

1000
00:48:37,600 --> 00:48:40,440
So this is just plain deferred shading.

1001
00:48:40,440 --> 00:48:43,000
Then if we do deferred with light proxies,

1002
00:48:43,000 --> 00:48:45,680
now you get the lights coming in and floating around.

1003
00:48:47,960 --> 00:48:48,920
Then we can do lights here.

1004
00:48:48,920 --> 00:48:51,960
So this was used to generate that image

1005
00:48:51,960 --> 00:48:53,600
that you saw in the slides.

1006
00:48:54,640 --> 00:48:56,120
Is there a pause button here?

1007
00:48:57,760 --> 00:48:59,280
I don't think so.

1008
00:48:59,280 --> 00:49:00,200
But essentially you can see

1009
00:49:00,280 --> 00:49:02,160
as the lights are roaming around,

1010
00:49:02,160 --> 00:49:04,120
the spheres are floating with the two.

1011
00:49:04,120 --> 00:49:06,720
Maybe let me change it to one light.

1012
00:49:06,720 --> 00:49:07,720
And then we can see.

1013
00:49:08,720 --> 00:49:11,600
So see how the sphere is floating with the lights.

1014
00:49:12,760 --> 00:49:13,960
I can stop that.

1015
00:49:13,960 --> 00:49:18,280
So let me go back into 50 lights

1016
00:49:18,280 --> 00:49:20,320
and then I'll pause the animation.

1017
00:49:20,320 --> 00:49:23,520
So now we can see how all the lights overlap

1018
00:49:23,520 --> 00:49:25,360
and stuff within that image.

1019
00:49:26,360 --> 00:49:30,760
Now, from these light spheres, right?

1020
00:49:30,760 --> 00:49:32,280
Let me zoom out.

1021
00:49:32,280 --> 00:49:33,840
We can compute the light influence.

1022
00:49:33,840 --> 00:49:36,480
The light sphere is not the light influence, okay?

1023
00:49:36,480 --> 00:49:38,480
The light influence is how it's affecting geometry.

1024
00:49:38,480 --> 00:49:40,120
So I'm going to switch that.

1025
00:49:40,120 --> 00:49:44,480
So now it's affecting this in 2D, essentially.

1026
00:49:44,480 --> 00:49:47,640
It's not a sphere, but it's more in 2D,

1027
00:49:47,640 --> 00:49:51,880
giving you a flat view of which light is affecting

1028
00:49:51,880 --> 00:49:53,920
which part of your screen.

1029
00:49:53,920 --> 00:49:56,520
So sphere, influence.

1030
00:49:58,120 --> 00:50:00,160
And then if you do influence add,

1031
00:50:00,160 --> 00:50:04,960
now you see where, what are the hot areas of your screen?

1032
00:50:04,960 --> 00:50:05,800
Right?

1033
00:50:05,800 --> 00:50:06,640
All the bright reds are where

1034
00:50:06,640 --> 00:50:09,280
there's more lights having an influence.

1035
00:50:09,280 --> 00:50:10,840
The dark areas are where

1036
00:50:10,840 --> 00:50:12,800
the lights are not having an influence.

1037
00:50:14,000 --> 00:50:14,840
If we do crop,

1038
00:50:14,840 --> 00:50:18,040
we only see where at least two lights are affecting.

1039
00:50:18,040 --> 00:50:21,960
And now you can see that with the geometry.

1040
00:50:21,960 --> 00:50:24,240
So if I zoom in here,

1041
00:50:24,240 --> 00:50:25,280
you can see the geometry

1042
00:50:25,280 --> 00:50:27,840
and how the geometry is affecting it.

1043
00:50:27,840 --> 00:50:30,840
And notice how there's no back geometry to this.

1044
00:50:30,840 --> 00:50:33,760
This was, I stopped somewhere like this,

1045
00:50:33,760 --> 00:50:35,720
and now there's only the front-facing geometry.

1046
00:50:35,720 --> 00:50:37,120
There's nothing at the back.

1047
00:50:38,920 --> 00:50:39,760
Right?

1048
00:50:39,760 --> 00:50:41,360
And that's because we are in this deferred pipeline

1049
00:50:41,360 --> 00:50:43,440
where we have paused the animation

1050
00:50:43,440 --> 00:50:45,720
to only see what is front-facing,

1051
00:50:45,720 --> 00:50:47,120
what's in the G-buffer.

1052
00:50:48,120 --> 00:50:50,120
And then if we do a fall-off,

1053
00:50:51,320 --> 00:50:53,920
now you see where the lights have no influence.

1054
00:50:53,920 --> 00:50:56,360
So I'll go from crop to fall-off,

1055
00:50:56,360 --> 00:50:58,120
where now you see,

1056
00:50:58,120 --> 00:51:00,480
like if you pay attention to this cone here,

1057
00:51:02,000 --> 00:51:03,920
see how this light,

1058
00:51:03,920 --> 00:51:06,280
while it has an influence, right?

1059
00:51:06,280 --> 00:51:08,880
The same light has an influence from here to here,

1060
00:51:08,880 --> 00:51:10,880
but it doesn't mean that

1061
00:51:10,880 --> 00:51:12,520
the light has the same influence

1062
00:51:12,520 --> 00:51:14,400
across its entire radius.

1063
00:51:14,400 --> 00:51:16,320
The light is gonna have more influence

1064
00:51:17,200 --> 00:51:19,160
close to its center

1065
00:51:19,160 --> 00:51:21,960
and less influence close to its edges, right?

1066
00:51:21,960 --> 00:51:24,360
So that's what this fall-off means,

1067
00:51:24,360 --> 00:51:27,800
where those edges have less influence.

1068
00:51:28,920 --> 00:51:31,120
Then you do shading with those lights.

1069
00:51:31,120 --> 00:51:32,960
And then if you add albedo,

1070
00:51:32,960 --> 00:51:34,200
then you get your colors.

1071
00:51:35,920 --> 00:51:38,400
So that's essentially the different stages

1072
00:51:38,400 --> 00:51:40,160
of the deferred rendering pipeline.

1073
00:51:43,080 --> 00:51:44,600
Let's come back to our slides.

1074
00:51:46,560 --> 00:51:49,440
So that is essentially

1075
00:51:49,440 --> 00:51:52,560
for all the deferred shading that is,

1076
00:51:52,560 --> 00:51:55,640
at least as we have in the slides,

1077
00:51:55,640 --> 00:51:57,360
there have been a lot more advances

1078
00:51:57,360 --> 00:51:59,960
in deferred shading through SIGGRAPH and stuff.

1079
00:51:59,960 --> 00:52:02,560
If you're interested in doing final projects

1080
00:52:02,560 --> 00:52:03,800
of any of them,

1081
00:52:03,800 --> 00:52:06,880
I'd be more than happy to encourage you to do that.

1082
00:52:08,760 --> 00:52:11,760
Both the project fives,

1083
00:52:12,600 --> 00:52:15,040
Vulcan and WebGL

1084
00:52:15,040 --> 00:52:17,360
have come from former students' final projects,

1085
00:52:17,360 --> 00:52:18,640
and I'd love to update them.

1086
00:52:18,640 --> 00:52:21,080
So if you're looking to doing new rendering,

1087
00:52:21,080 --> 00:52:22,640
real-time rendering pipelines,

1088
00:52:22,640 --> 00:52:24,440
would certainly encourage that.

1089
00:52:26,400 --> 00:52:28,800
So that's the first part of my lecture,

1090
00:52:28,800 --> 00:52:30,080
which is deferred shading.

1091
00:52:31,080 --> 00:52:32,080
We're gonna take,

1092
00:52:33,080 --> 00:52:36,160
we'll do the recitation for project four.

1093
00:52:36,160 --> 00:52:37,040
We'll take a break,

1094
00:52:37,040 --> 00:52:38,480
and then we'll do the second part,

1095
00:52:38,480 --> 00:52:40,240
which is forward plus rendering,

1096
00:52:40,240 --> 00:52:41,520
which takes a different view

1097
00:52:41,520 --> 00:52:43,960
on how we can do even more lights,

1098
00:52:43,960 --> 00:52:45,480
even more materials,

1099
00:52:45,480 --> 00:52:48,680
and take a look at that after the recitation on the break.

1100
00:52:49,960 --> 00:52:53,080
So I'll pause there, Shubham, whenever you're ready.

1101
00:53:04,040 --> 00:53:08,320
So I have the instructions open here if you need them.

1102
00:53:11,040 --> 00:53:12,480
So I'll just look at it.

1103
00:53:14,360 --> 00:53:17,240
So, I'm getting a bit of a, I should just-

1104
00:53:17,240 --> 00:53:18,080
No, go ahead.

1105
00:53:18,080 --> 00:53:20,600
You get started, we'll get on the break after.

1106
00:53:20,600 --> 00:53:21,440
So smoking.

1107
00:53:22,360 --> 00:53:23,200
Okay.

1108
00:53:42,320 --> 00:53:45,640
Talk about something, which is denoising.

1109
00:53:45,640 --> 00:53:49,640
And so I hope all of you enjoyed your project,

1110
00:53:49,640 --> 00:53:51,480
the ray tracing project.

1111
00:53:51,480 --> 00:53:53,720
But all of you must have noticed

1112
00:53:53,720 --> 00:53:57,320
that when we are iterating through like samples per pixel,

1113
00:53:57,320 --> 00:53:59,920
initially the image is very grainy.

1114
00:53:59,920 --> 00:54:03,080
And that is something that we're trying to solve

1115
00:54:03,080 --> 00:54:04,240
with denoising images,

1116
00:54:04,240 --> 00:54:06,280
that we're trying to convert the images faster.

1117
00:54:06,280 --> 00:54:11,080
If you can't do it through some concepts of path tracing,

1118
00:54:11,080 --> 00:54:12,720
then we'll take a different approach

1119
00:54:12,720 --> 00:54:15,000
and we'll denoise those images.

1120
00:54:15,000 --> 00:54:19,560
So that's what I talked about right now.

1121
00:54:20,480 --> 00:54:22,920
And let's see what happens.

1122
00:54:22,920 --> 00:54:24,480
Like, how do we do that?

1123
00:54:24,480 --> 00:54:28,760
So, it says that it's especially true

1124
00:54:28,760 --> 00:54:30,240
for simple path traces,

1125
00:54:30,240 --> 00:54:32,480
like our basic version of project three.

1126
00:54:32,480 --> 00:54:34,640
Light paths, they terminate as black.

1127
00:54:34,640 --> 00:54:36,960
And that's why you see a lot of grainy grains

1128
00:54:36,960 --> 00:54:38,440
on your images.

1129
00:54:38,440 --> 00:54:41,520
And rays scatter randomly on diffuse surfaces.

1130
00:54:41,520 --> 00:54:44,120
That's why it takes a lot of time

1131
00:54:44,120 --> 00:54:47,360
for your image to be converged.

1132
00:54:47,360 --> 00:54:49,560
So, we have noise worse

1133
00:54:49,560 --> 00:54:52,680
when light paths are unlikely to hit light sources.

1134
00:54:52,680 --> 00:54:56,200
So, if you have, let's say one light source in your scene

1135
00:54:56,200 --> 00:54:59,760
and you send a lot of light rays into your scene,

1136
00:54:59,760 --> 00:55:01,720
many of them will never reach a light source.

1137
00:55:01,720 --> 00:55:03,640
So, it will just give you a black color

1138
00:55:03,640 --> 00:55:05,280
or the pixel light.

1139
00:55:05,280 --> 00:55:07,600
So, that's what we see in like our scenes,

1140
00:55:07,600 --> 00:55:10,760
which has a lot of geometry or a lack of lighting,

1141
00:55:10,760 --> 00:55:14,040
that your image is gonna take a lot of time to converge.

1142
00:55:14,040 --> 00:55:16,920
And that's where the denoising comes into play.

1143
00:55:18,520 --> 00:55:20,000
And we have this third point,

1144
00:55:20,000 --> 00:55:21,600
which says that noise reduction

1145
00:55:21,600 --> 00:55:25,200
usually doesn't scale linearly with more iterations.

1146
00:55:25,200 --> 00:55:27,320
What it means by that is that,

1147
00:55:27,320 --> 00:55:31,640
let's say you have an image

1148
00:55:31,640 --> 00:55:35,120
which has like 10 samples per pixel.

1149
00:55:35,120 --> 00:55:35,960
Yeah, you just started here.

1150
00:55:35,960 --> 00:55:38,000
You have one sample per pixel.

1151
00:55:38,000 --> 00:55:39,240
Your image is very green.

1152
00:55:39,240 --> 00:55:40,080
You denoise it.

1153
00:55:40,080 --> 00:55:41,600
You will have some effect.

1154
00:55:41,600 --> 00:55:44,840
Your image now has 500 iterations.

1155
00:55:44,840 --> 00:55:47,360
It's way more converged than the first image.

1156
00:55:47,360 --> 00:55:48,200
You denoise it.

1157
00:55:48,200 --> 00:55:50,040
You get some results.

1158
00:55:50,040 --> 00:55:52,600
But then when you reach 1000 iterations,

1159
00:55:52,600 --> 00:55:54,520
your image is, it's gonna be,

1160
00:55:54,520 --> 00:55:57,640
it's not gonna have that much of an effect

1161
00:55:57,640 --> 00:56:00,000
when you see from 10, going from 10 to 100,

1162
00:56:00,000 --> 00:56:01,480
going from 100 to 500.

1163
00:56:01,480 --> 00:56:03,320
And that's what we will see now.

1164
00:56:03,320 --> 00:56:05,200
And that's what it means by like,

1165
00:56:05,200 --> 00:56:09,480
the denoising doesn't scale linearly with more iterations.

1166
00:56:09,480 --> 00:56:10,920
So, let's see how it works.

1167
00:56:10,920 --> 00:56:13,320
So, we have this one sample per pixel image.

1168
00:56:14,680 --> 00:56:19,200
Then by 11, and then 99, and then 501.

1169
00:56:19,200 --> 00:56:23,680
You see that now the image is fairly acceptable,

1170
00:56:23,680 --> 00:56:25,720
but it still has a lot of greens, right?

1171
00:56:27,320 --> 00:56:30,000
Now, when I reach 1000 samples per pixels,

1172
00:56:30,000 --> 00:56:34,240
from 500 to 1000, you didn't see much of a difference.

1173
00:56:34,240 --> 00:56:37,840
And I'm not saying that it looks 2x better.

1174
00:56:37,840 --> 00:56:40,360
So, like from here to here, I can say,

1175
00:56:40,880 --> 00:56:43,040
yeah, it looks way better, right?

1176
00:56:43,040 --> 00:56:46,760
Yeah, it looks way better for going from 99 to 500,

1177
00:56:46,760 --> 00:56:50,800
but it's not that great from going from like 500 to 1000.

1178
00:56:50,800 --> 00:56:52,800
So, you can't quantify it, right?

1179
00:56:52,800 --> 00:56:54,800
It's just how your eyes see that.

1180
00:56:56,960 --> 00:57:01,080
So, that's how the noise denoising is gonna be.

1181
00:57:01,080 --> 00:57:03,160
Initially, it's gonna perform really good,

1182
00:57:03,160 --> 00:57:05,120
but as we go with more iterations,

1183
00:57:05,120 --> 00:57:07,480
it's not gonna perform as good as it used to.

1184
00:57:08,080 --> 00:57:13,080
So, now this is like the fun part.

1185
00:57:13,800 --> 00:57:16,440
I don't know how many of you have taken the 460 class,

1186
00:57:16,440 --> 00:57:20,680
but all of us, we had that Gaussian blur

1187
00:57:20,680 --> 00:57:22,920
on Wahoo, the Mario thingy.

1188
00:57:22,920 --> 00:57:25,440
And when we did the Gaussian blur,

1189
00:57:25,440 --> 00:57:26,920
it just blurred out the image, right?

1190
00:57:26,920 --> 00:57:29,000
The whole image was blurred.

1191
00:57:29,000 --> 00:57:31,960
So, that's how we create like blurring

1192
00:57:31,960 --> 00:57:33,520
post-processing effects.

1193
00:57:33,520 --> 00:57:37,960
But what it does is it blurs the whole image, right?

1194
00:57:37,960 --> 00:57:42,480
And I want my blur to stop at certain point.

1195
00:57:42,480 --> 00:57:45,760
Let's say that you take a photo of me

1196
00:57:46,720 --> 00:57:49,800
and then you denoise it and you just blurred me out.

1197
00:57:49,800 --> 00:57:53,240
Like, I am like, you can't even see,

1198
00:57:54,320 --> 00:57:57,320
like differentiate me from the background.

1199
00:57:57,320 --> 00:57:59,320
But what if you stop at the edges?

1200
00:57:59,320 --> 00:58:01,120
Like if I have like my image

1201
00:58:01,120 --> 00:58:04,280
and you stop blurring me as soon as you found that,

1202
00:58:04,280 --> 00:58:07,840
okay, my like this, and that is different.

1203
00:58:07,840 --> 00:58:10,280
So, that's when your blurring is gonna be like really good.

1204
00:58:10,280 --> 00:58:11,240
It's gonna be effective.

1205
00:58:11,240 --> 00:58:14,080
It's gonna create a denoising effect, right?

1206
00:58:14,080 --> 00:58:15,680
So, let's see how it looks like.

1207
00:58:15,680 --> 00:58:18,600
So, for some scenes and materials,

1208
00:58:18,600 --> 00:58:21,120
as I told you about, it's gonna work great.

1209
00:58:21,120 --> 00:58:25,080
And we can control the blur with more per pixel info.

1210
00:58:25,080 --> 00:58:26,200
So, basic concept,

1211
00:58:26,200 --> 00:58:29,440
you just learned about G buffers, what they are.

1212
00:58:29,440 --> 00:58:34,440
So, let's say that I store the normals and the colors, right?

1213
00:58:34,800 --> 00:58:37,960
So, my normal, like at each of,

1214
00:58:37,960 --> 00:58:40,280
let's say like I have UVs and my normals,

1215
00:58:40,280 --> 00:58:43,000
like each point is gonna be different than this wall.

1216
00:58:43,000 --> 00:58:44,000
So, you can detect, okay,

1217
00:58:44,000 --> 00:58:46,040
I am a different object than this wall.

1218
00:58:46,040 --> 00:58:47,320
So, that means you can stop

1219
00:58:47,320 --> 00:58:49,120
when you're denoising me from that wall,

1220
00:58:49,120 --> 00:58:51,520
you can get that edge, right?

1221
00:58:51,520 --> 00:58:53,080
And the same thing goes for pixels.

1222
00:58:53,080 --> 00:58:54,200
Like it depends upon the scene,

1223
00:58:54,200 --> 00:58:58,480
but if this board is different than this board,

1224
00:58:58,920 --> 00:59:00,160
in terms of color, right?

1225
00:59:00,160 --> 00:59:02,000
So, when I'm denoising this image,

1226
00:59:02,000 --> 00:59:03,280
I will say, okay, stop here.

1227
00:59:03,280 --> 00:59:07,240
Like don't count in these pixels because this is an edge.

1228
00:59:07,240 --> 00:59:09,560
So, that's what we have here,

1229
00:59:09,560 --> 00:59:12,560
that we have an image, which is like this.

1230
00:59:12,560 --> 00:59:14,960
If you just apply a simple Gaussian blur,

1231
00:59:14,960 --> 00:59:15,800
it's too blurred out,

1232
00:59:15,800 --> 00:59:18,560
you can't make anything out of it.

1233
00:59:18,560 --> 00:59:22,040
So, we store positions inside our G buffer,

1234
00:59:22,040 --> 00:59:23,400
which looks like that.

1235
00:59:23,400 --> 00:59:25,600
And then you also store normals.

1236
00:59:25,640 --> 00:59:28,200
And if you add all of this up,

1237
00:59:28,200 --> 00:59:29,040
as I told you about,

1238
00:59:29,040 --> 00:59:31,920
if you stop blurring out

1239
00:59:31,920 --> 00:59:35,240
when you see difference in normals and positions,

1240
00:59:35,240 --> 00:59:37,080
you're gonna see something like that.

1241
00:59:37,080 --> 00:59:40,480
And this is what we're aiming for in this project,

1242
00:59:40,480 --> 00:59:42,640
that we wanna build a denoiser,

1243
00:59:42,640 --> 00:59:47,360
which performs really good when we detect some edges

1244
00:59:47,360 --> 00:59:48,880
and we blur out those pixels.

1245
00:59:50,880 --> 00:59:54,800
So, we are basing off our implementation

1246
00:59:54,840 --> 00:59:57,840
from this amazing paper, the 8Ru paper.

1247
00:59:57,840 --> 00:59:59,360
And the key take up,

1248
00:59:59,360 --> 01:00:02,440
like it's like, it has a lot of fancy terms inside the paper

1249
01:00:02,440 --> 01:00:03,880
when you read through it.

1250
01:00:03,880 --> 01:00:07,840
But the main idea is what I just talked about,

1251
01:00:07,840 --> 01:00:12,000
that we're gonna approximate blur filters like Gaussian blur

1252
01:00:12,000 --> 01:00:13,320
with fewer memory reads.

1253
01:00:13,320 --> 01:00:14,560
And that is like one thing,

1254
01:00:14,560 --> 01:00:17,240
if you want to blur the whole image,

1255
01:00:17,240 --> 01:00:19,440
you have a bunch of pixels and you start a kernel

1256
01:00:19,440 --> 01:00:22,600
and then every thread is just blurring one pixel out.

1257
01:00:22,600 --> 01:00:25,120
It's gonna be like way,

1258
01:00:25,120 --> 01:00:27,360
like it's not gonna be memory efficient

1259
01:00:27,360 --> 01:00:31,040
because every thread is reading a bunch of values

1260
01:00:31,040 --> 01:00:33,440
from the global memory pool, right?

1261
01:00:34,280 --> 01:00:38,280
So, we're gonna see how we optimize those memory reads.

1262
01:00:38,280 --> 01:00:41,000
And that's what we saw in this paper.

1263
01:00:41,000 --> 01:00:46,000
And now we move on to here.

1264
01:00:46,320 --> 01:00:50,160
So, I don't know if a lot of,

1265
01:00:50,200 --> 01:00:53,040
like, has anybody seen Gaussian kernel before?

1266
01:00:53,040 --> 01:00:53,880
Yeah.

1267
01:00:53,880 --> 01:00:56,240
So, like, don't worry about that.

1268
01:00:56,240 --> 01:00:59,320
So, a Gaussian core is like this.

1269
01:01:00,200 --> 01:01:03,200
So, it's maximum, the maximum value is at the center.

1270
01:01:03,200 --> 01:01:04,480
And when we go away,

1271
01:01:04,480 --> 01:01:06,160
like when we go away to like move from,

1272
01:01:06,160 --> 01:01:08,240
in like standard deviation, it just reduces down.

1273
01:01:08,240 --> 01:01:10,120
That's what's happening here.

1274
01:01:10,120 --> 01:01:11,440
So, maximum value.

1275
01:01:11,440 --> 01:01:13,160
And when we go in any direction,

1276
01:01:13,160 --> 01:01:15,640
which is like away from it, the value decreases.

1277
01:01:15,640 --> 01:01:18,280
And that's how the pixel blurring works, right?

1278
01:01:18,280 --> 01:01:20,760
Because the current pixel that I'm currently,

1279
01:01:20,760 --> 01:01:22,200
like the working on,

1280
01:01:22,200 --> 01:01:24,360
I'm gonna have the maximum value from that,

1281
01:01:24,360 --> 01:01:26,160
maximum data from that.

1282
01:01:26,160 --> 01:01:27,680
And when I move away from it,

1283
01:01:27,680 --> 01:01:30,560
I'm gonna take like less and less and less.

1284
01:01:30,560 --> 01:01:32,520
So, that's just like a Gaussian blur.

1285
01:01:33,720 --> 01:01:38,200
And yeah, so, this is the pseudocode for,

1286
01:01:38,200 --> 01:01:40,920
the pseudocode for the Gaussian blur for each pixel.

1287
01:01:40,920 --> 01:01:44,360
Being blurred, we sample every pixel in the blur radius.

1288
01:01:44,360 --> 01:01:48,080
And we multiply by a weight, which is from your kernel.

1289
01:01:48,880 --> 01:01:50,600
And let's say that the color and the,

1290
01:01:50,600 --> 01:01:52,480
this weight is just multiplying with every,

1291
01:01:52,480 --> 01:01:54,880
the colors or the pixels of your final image.

1292
01:01:54,880 --> 01:01:57,920
And you'll get the final color of the one pixel.

1293
01:01:59,080 --> 01:02:02,560
So, now Gaussian blurs, they usually,

1294
01:02:02,560 --> 01:02:04,880
they usually do blurring on like some filter,

1295
01:02:04,880 --> 01:02:06,160
which is of some size.

1296
01:02:06,160 --> 01:02:09,600
So, let's say that this previous one was,

1297
01:02:09,600 --> 01:02:10,920
I don't know how much,

1298
01:02:10,920 --> 01:02:13,400
one, two, three, four, five, six, seven.

1299
01:02:13,400 --> 01:02:14,240
It's seven by seven.

1300
01:02:14,240 --> 01:02:17,040
Oh, it's seven, it's a seven by seven filter.

1301
01:02:17,040 --> 01:02:18,880
But if I want to blur,

1302
01:02:18,880 --> 01:02:22,880
if I want to do this blurring with a 16 by 16 filter,

1303
01:02:22,880 --> 01:02:25,160
which is, it's going to be like huge.

1304
01:02:25,160 --> 01:02:28,320
Because for every pixel, I'm going to read like,

1305
01:02:28,320 --> 01:02:30,040
what is 16 into 16?

1306
01:02:30,040 --> 01:02:31,000
256?

1307
01:02:31,000 --> 01:02:34,200
Yeah, 256, oh, it's a dimension.

1308
01:02:34,200 --> 01:02:35,040
Yes.

1309
01:02:35,040 --> 01:02:38,120
So, it's, so I'm going to read like 256 pixels

1310
01:02:38,120 --> 01:02:39,640
for every pixel.

1311
01:02:39,640 --> 01:02:40,920
Like, so it's going to be, I don't know,

1312
01:02:40,920 --> 01:02:43,680
like how much, 19, 20 to 10, 80 pixels.

1313
01:02:43,680 --> 01:02:48,080
Each of them doing 256 calculation every time.

1314
01:02:48,080 --> 01:02:49,400
So, it's like too much, right?

1315
01:02:49,400 --> 01:02:52,040
So, I have to find a way to optimize this.

1316
01:02:53,360 --> 01:02:57,480
So, how it's done in, like,

1317
01:02:57,480 --> 01:02:58,680
how A2A explained that,

1318
01:02:58,680 --> 01:03:02,520
how we found a good way to optimize this thing is that,

1319
01:03:02,520 --> 01:03:05,400
instead of doing a 16 by 16 curtail,

1320
01:03:05,400 --> 01:03:08,440
instead of using that, I use five by five curtail.

1321
01:03:08,440 --> 01:03:13,440
And what I do is, I first use the five by five curtail weights

1322
01:03:13,480 --> 01:03:15,560
to find the color for this pixel,

1323
01:03:15,560 --> 01:03:17,120
which is like center.

1324
01:03:17,120 --> 01:03:19,840
And next slide, in next iteration,

1325
01:03:19,840 --> 01:03:23,560
I'm going to use the same five by five filter.

1326
01:03:23,560 --> 01:03:26,720
And instead of taking these pixels for the values,

1327
01:03:26,720 --> 01:03:28,600
I'm going to take these pixels.

1328
01:03:28,600 --> 01:03:31,880
So, there's like a bunch of pixels here

1329
01:03:31,880 --> 01:03:34,080
that I'm not taking into consideration,

1330
01:03:34,080 --> 01:03:36,240
and I expanded my filter.

1331
01:03:36,240 --> 01:03:37,560
So, that's what I'm doing.

1332
01:03:37,560 --> 01:03:40,360
Every iteration, I expand my filter,

1333
01:03:40,360 --> 01:03:42,400
and I add, so these are like,

1334
01:03:42,440 --> 01:03:43,880
are going to be like a bunch of pixels

1335
01:03:43,880 --> 01:03:45,280
that I don't care about,

1336
01:03:45,280 --> 01:03:47,320
and every time I get more pixels.

1337
01:03:47,320 --> 01:03:48,520
So, I'm doing the same effect.

1338
01:03:48,520 --> 01:03:51,640
I'm having the same 16 by 16 effect

1339
01:03:51,640 --> 01:03:54,040
by using a five by five curtail.

1340
01:03:56,720 --> 01:04:01,720
So, that's what we have here for a five by five filter.

1341
01:04:01,720 --> 01:04:04,920
And I want to do 16 by 16 blur.

1342
01:04:04,920 --> 01:04:06,360
So, what I do is,

1343
01:04:06,360 --> 01:04:10,000
I'm going to just do 25 pixel reads every iteration,

1344
01:04:10,000 --> 01:04:11,360
and I'm going to do it three times.

1345
01:04:11,360 --> 01:04:12,680
Why? Because like five into three

1346
01:04:12,680 --> 01:04:16,520
and five into three is approximately that same value.

1347
01:04:16,520 --> 01:04:19,560
So, we have 75 pixel reads per pixel blur

1348
01:04:19,560 --> 01:04:22,080
instead of two pixel reads for Gaussian.

1349
01:04:23,400 --> 01:04:25,120
And then the total number of pixel reads

1350
01:04:25,120 --> 01:04:27,400
gets more slowly when increasing blur size,

1351
01:04:27,400 --> 01:04:31,360
because now we just have like a small blur kernel,

1352
01:04:31,360 --> 01:04:33,480
and then we just like expand it.

1353
01:04:33,480 --> 01:04:37,200
So, it's going to expand like way more less,

1354
01:04:37,200 --> 01:04:38,680
like it's going to be way more efficient

1355
01:04:38,680 --> 01:04:40,600
when we slowly increase the blur size.

1356
01:04:42,360 --> 01:04:46,400
So, the G-Buffer,

1357
01:04:46,400 --> 01:04:49,480
we'd store per pixel information for surfaces

1358
01:04:49,480 --> 01:04:51,160
seen beyond the ray trace color.

1359
01:04:52,240 --> 01:04:54,440
What we store in G-Buffer is the position

1360
01:04:54,440 --> 01:04:55,320
and just the normals.

1361
01:04:55,320 --> 01:04:56,920
I think that will be enough for us.

1362
01:04:56,920 --> 01:05:00,280
We'll also add color, but let's see how it scales.

1363
01:05:00,280 --> 01:05:01,320
So, that's what it says.

1364
01:05:01,320 --> 01:05:03,600
What else might be useful for edge detection

1365
01:05:03,600 --> 01:05:04,720
and detail preservation?

1366
01:05:04,720 --> 01:05:05,880
Color. Color will definitely,

1367
01:05:05,880 --> 01:05:08,160
because the surface is different color than that surface.

1368
01:05:08,160 --> 01:05:10,960
So, we can know that these two surfaces

1369
01:05:11,080 --> 01:05:12,080
are different.

1370
01:05:12,080 --> 01:05:14,760
Sometimes these things might not come into play

1371
01:05:14,760 --> 01:05:17,800
because let's say that this and this surface

1372
01:05:17,800 --> 01:05:20,040
is like different, it's of a different material,

1373
01:05:20,040 --> 01:05:22,000
like the normal mapping is different,

1374
01:05:22,000 --> 01:05:23,040
but they are of the same color,

1375
01:05:23,040 --> 01:05:25,240
but I still wanted to preserve that edge.

1376
01:05:25,240 --> 01:05:26,160
That edge will be lost.

1377
01:05:26,160 --> 01:05:30,000
So, that's why we will make all of these factors somehow.

1378
01:05:30,000 --> 01:05:31,720
Well, this might have different normals than that.

1379
01:05:31,720 --> 01:05:35,080
So, sometimes normal will be more come into play,

1380
01:05:35,080 --> 01:05:37,680
sometimes position will come into play, sometimes color.

1381
01:05:37,680 --> 01:05:41,040
And we'll have to like squeeze all of these factors,

1382
01:05:41,040 --> 01:05:43,520
you know, like in one equation to find out

1383
01:05:43,520 --> 01:05:47,120
a perfect equation which works for the edge detection.

1384
01:05:48,400 --> 01:05:51,840
So, we'll also see how it works,

1385
01:05:51,840 --> 01:05:53,360
how this scaling will work,

1386
01:05:53,360 --> 01:05:55,560
this edge detection and everything will work

1387
01:05:55,560 --> 01:05:59,400
with reflective, refractive and translucent material.

1388
01:05:59,400 --> 01:06:00,760
I'm not gonna talk about it,

1389
01:06:00,760 --> 01:06:03,440
but I think in your readme slide,

1390
01:06:03,440 --> 01:06:04,720
you have to write about it.

1391
01:06:04,720 --> 01:06:06,200
So, write good answers.

1392
01:06:07,720 --> 01:06:08,720
So, yeah.

1393
01:06:08,720 --> 01:06:10,560
So, now let's look at the paper.

1394
01:06:10,560 --> 01:06:13,520
The paper, yeah, it looks kind of daunting,

1395
01:06:13,520 --> 01:06:15,040
like it's too much to read,

1396
01:06:15,040 --> 01:06:16,440
but I'm just gonna make it like,

1397
01:06:16,440 --> 01:06:18,120
it's actually a simpler way

1398
01:06:18,120 --> 01:06:20,360
and then you can read it on your own.

1399
01:06:20,360 --> 01:06:22,120
But what it tells is that,

1400
01:06:24,280 --> 01:06:27,040
so, just like think about this thing for now,

1401
01:06:27,040 --> 01:06:31,160
which is like, I want to calculate the color of my pixel

1402
01:06:31,160 --> 01:06:33,480
using my Gaussian kernel

1403
01:06:33,480 --> 01:06:36,120
and some of the ways that I calculated, right?

1404
01:06:36,120 --> 01:06:38,120
So, coming here,

1405
01:06:38,120 --> 01:06:40,880
this weight is based on some normal,

1406
01:06:40,880 --> 01:06:44,880
some position and some input image, right?

1407
01:06:44,880 --> 01:06:46,520
So, they're using a normal buffer,

1408
01:06:46,520 --> 01:06:49,800
a position buffer and the weighted input image.

1409
01:06:49,800 --> 01:06:51,000
And what we do is,

1410
01:06:53,160 --> 01:06:56,520
how do we tell that one value is too different,

1411
01:06:56,520 --> 01:06:58,120
too much different than the other, right?

1412
01:06:58,120 --> 01:07:00,040
I just calculate the distance between them.

1413
01:07:00,040 --> 01:07:01,080
It might be like anything,

1414
01:07:01,080 --> 01:07:03,200
like let's say I have a normal value,

1415
01:07:03,200 --> 01:07:04,760
it has some x, y, z coordinates.

1416
01:07:04,800 --> 01:07:08,080
I have another normal, which has some x, y, z coordinates.

1417
01:07:08,080 --> 01:07:10,200
Calculating the distance between two normals

1418
01:07:10,200 --> 01:07:11,640
doesn't make any sense.

1419
01:07:11,640 --> 01:07:13,080
But if I just do this,

1420
01:07:13,080 --> 01:07:15,640
like the same distance calculation

1421
01:07:15,640 --> 01:07:19,400
to calculate the distance between these x, y and z values,

1422
01:07:19,400 --> 01:07:21,840
it will tell me how it's different there, right?

1423
01:07:21,840 --> 01:07:24,360
So, first thing is that,

1424
01:07:24,360 --> 01:07:27,120
so, there's like this way to calculate

1425
01:07:27,120 --> 01:07:30,000
how much different the two things are.

1426
01:07:30,000 --> 01:07:31,400
And then the second thing is,

1427
01:07:31,400 --> 01:07:34,080
if something is like different,

1428
01:07:34,320 --> 01:07:35,880
if it's more different,

1429
01:07:35,880 --> 01:07:37,200
I want to scale it,

1430
01:07:37,200 --> 01:07:39,040
like I want to weigh less.

1431
01:07:39,040 --> 01:07:40,960
So, that's why this equation tells you something,

1432
01:07:40,960 --> 01:07:44,440
like if this is like an exponential equation,

1433
01:07:44,440 --> 01:07:48,320
which tells me if this is like E minus D upon two,

1434
01:07:48,320 --> 01:07:49,360
if the distance is like,

1435
01:07:49,360 --> 01:07:52,880
so, it's gonna be like one upon E D by two.

1436
01:07:52,880 --> 01:07:55,520
So, it tells me that if distance increase,

1437
01:07:55,520 --> 01:07:57,880
I should decrease the weightage I'm giving to that.

1438
01:07:57,880 --> 01:08:01,080
So, like, if this is a normal for this surface

1439
01:08:01,080 --> 01:08:02,400
and that is a normal,

1440
01:08:02,400 --> 01:08:04,760
which is like two different for two surfaces

1441
01:08:04,760 --> 01:08:06,400
and the distance is large,

1442
01:08:06,400 --> 01:08:10,120
that means I don't want this thing to weigh more

1443
01:08:10,120 --> 01:08:11,640
because these things are too much there.

1444
01:08:11,640 --> 01:08:14,800
That's why we have this one upon exponential of some,

1445
01:08:14,800 --> 01:08:17,480
because that's like that function right there.

1446
01:08:17,480 --> 01:08:19,520
So, one thing we conquered.

1447
01:08:19,520 --> 01:08:21,440
Second thing is this weight.

1448
01:08:21,440 --> 01:08:23,920
So, this weight is actually a combination of three things.

1449
01:08:23,920 --> 01:08:27,560
So, you calculate the difference between the normal,

1450
01:08:27,560 --> 01:08:29,280
like how different they are.

1451
01:08:29,280 --> 01:08:32,080
You have a weight for position.

1452
01:08:32,760 --> 01:08:33,920
So, it's like the things are two different,

1453
01:08:33,920 --> 01:08:35,040
like two different positions

1454
01:08:35,040 --> 01:08:36,720
that I know that they are too far apart.

1455
01:08:36,720 --> 01:08:38,200
There might be a length there.

1456
01:08:39,280 --> 01:08:42,400
And then I think we also have the range-range input image

1457
01:08:42,400 --> 01:08:44,800
which we might be using for color or something.

1458
01:08:45,960 --> 01:08:50,960
So, finally, what this image is doing is that it says,

1459
01:08:51,240 --> 01:08:53,480
for a pixel P, which is my current pixel,

1460
01:08:53,480 --> 01:08:54,880
and for the pixel Q,

1461
01:08:54,880 --> 01:08:57,200
which are like all the pixels inside my kernel.

1462
01:08:57,200 --> 01:08:59,920
So, if I'm using a five by five kernel,

1463
01:08:59,960 --> 01:09:03,680
it's gonna be five by five pixels around me.

1464
01:09:03,680 --> 01:09:05,880
Five by five minus five pixels around me.

1465
01:09:05,880 --> 01:09:10,160
I'm just gonna do the weight calculation for all of them.

1466
01:09:10,160 --> 01:09:11,920
I have my color.

1467
01:09:11,920 --> 01:09:16,920
I have like a weighted value for all of the other pixels.

1468
01:09:17,000 --> 01:09:20,000
And I think this is like the Gaussian kernel value.

1469
01:09:20,000 --> 01:09:21,880
So, I use the weights, the Gaussian kernel,

1470
01:09:21,880 --> 01:09:23,200
and the color of that pixel,

1471
01:09:23,200 --> 01:09:25,000
that is like my surrounding pixel.

1472
01:09:25,000 --> 01:09:28,920
And I like add those up and average that out

1473
01:09:29,760 --> 01:09:34,280
which is the sum of all these weights.

1474
01:09:34,280 --> 01:09:36,680
I average that out and that's gonna be my value.

1475
01:09:36,680 --> 01:09:38,800
So, now, coming on to here,

1476
01:09:38,800 --> 01:09:41,760
this code is exactly doing that.

1477
01:09:41,760 --> 01:09:45,320
It just calculates the force, which is I think.

1478
01:09:45,320 --> 01:09:49,680
So, we store the color value, the normal, the P value.

1479
01:09:49,680 --> 01:09:52,280
We calculate the weighting factor from there,

1480
01:09:52,280 --> 01:09:54,800
which is like the color weight, the normal weight,

1481
01:09:57,280 --> 01:09:58,840
the position weight.

1482
01:09:59,720 --> 01:10:00,560
And then at the end,

1483
01:10:00,560 --> 01:10:03,480
I'm just averaging a bunch of these values, five by five.

1484
01:10:03,480 --> 01:10:06,080
And this equation works perfectly.

1485
01:10:06,080 --> 01:10:08,080
It's really good in detecting edges

1486
01:10:08,080 --> 01:10:10,560
and stopping blurring whenever there's an edge.

1487
01:10:12,840 --> 01:10:16,880
And, okay, I think I explained all of this.

1488
01:10:16,880 --> 01:10:18,280
So, what is this in this code?

1489
01:10:18,280 --> 01:10:20,720
So, this is like, I think, a fragment shader code

1490
01:10:20,720 --> 01:10:22,400
that is mentioned in the paper.

1491
01:10:22,400 --> 01:10:25,880
And we are gonna implement this in our CUDA kernels.

1492
01:10:25,880 --> 01:10:27,840
So, the kernel is our Gaussian kernel.

1493
01:10:29,440 --> 01:10:31,040
The offsets are these things.

1494
01:10:31,040 --> 01:10:32,960
So, initially, there's no offset.

1495
01:10:32,960 --> 01:10:35,880
So, we start off, let's check on the first iteration.

1496
01:10:35,880 --> 01:10:38,520
There's like, let me show you.

1497
01:10:38,520 --> 01:10:39,800
So, here.

1498
01:10:39,800 --> 01:10:42,920
So, you see that two to the power i minus one factor there.

1499
01:10:42,920 --> 01:10:45,800
So, like my first iteration, there is like,

1500
01:10:45,800 --> 01:10:48,000
so, that tells me how many zeros are there

1501
01:10:48,000 --> 01:10:49,160
between two values.

1502
01:10:49,160 --> 01:10:50,000
So, if I,

1503
01:10:55,080 --> 01:10:56,840
so, here, there's like no.

1504
01:10:56,840 --> 01:10:59,360
So, if I come here to here,

1505
01:10:59,360 --> 01:11:04,360
you will see that there's no zero between two values.

1506
01:11:05,360 --> 01:11:07,520
Like, this is the lowest kernel.

1507
01:11:07,520 --> 01:11:09,240
Then, the next iteration,

1508
01:11:09,240 --> 01:11:13,840
I have one zero between every bit.

1509
01:11:13,840 --> 01:11:15,200
So, that's my offset.

1510
01:11:15,200 --> 01:11:17,320
So, I just keep on increasing this offset.

1511
01:11:17,320 --> 01:11:19,800
Every iteration, I increase the offset.

1512
01:11:19,800 --> 01:11:24,240
And then, like, how much I want to blur my image.

1513
01:11:24,280 --> 01:11:28,440
How much I want my blur, the kernel to be.

1514
01:11:28,440 --> 01:11:29,280
So, yeah.

1515
01:11:29,280 --> 01:11:31,080
So, at the end, what we have is,

1516
01:11:31,080 --> 01:11:34,760
here, for all the values in the kernel,

1517
01:11:34,760 --> 01:11:37,560
I'm just like, going through all the pixels now,

1518
01:11:37,560 --> 01:11:39,920
and applying this same formula.

1519
01:11:39,920 --> 01:11:42,360
So, for pragmashifter, it's a perfection program.

1520
01:11:42,360 --> 01:11:44,240
Pragmashifter is for what's for each

1521
01:11:44,240 --> 01:11:45,760
in relation to the exceeding separate.

1522
01:11:45,760 --> 01:11:46,640
So, it's same.

1523
01:11:46,640 --> 01:11:51,280
So, I start with my original Gaussian kernel.

1524
01:11:51,280 --> 01:11:55,400
I calculate the final result for every pixel.

1525
01:11:55,400 --> 01:11:59,720
Now, the next iteration, I'm going to have this kernel.

1526
01:12:02,080 --> 01:12:04,360
This kernel instead of that, which has some separate,

1527
01:12:04,360 --> 01:12:06,640
because I'm, like, stepping my way by, like,

1528
01:12:06,640 --> 01:12:09,280
some, let's say, from one unit value.

1529
01:12:09,280 --> 01:12:10,240
I'm going to do that again,

1530
01:12:10,240 --> 01:12:12,280
and I'm going to do it a one more time.

1531
01:12:12,280 --> 01:12:14,920
And at the end, I will have a final result.

1532
01:12:14,920 --> 01:12:17,640
So, for loop handles gathering neighboring pixels

1533
01:12:17,640 --> 01:12:20,080
based on the A2 filter, which is like my bottom picture,

1534
01:12:20,080 --> 01:12:22,640
which is 515256, and I keep expanding it.

1535
01:12:25,400 --> 01:12:29,600
So, I think, yeah, this slide has also these

1536
01:12:29,600 --> 01:12:32,360
color coding patterns, which are telling you

1537
01:12:32,360 --> 01:12:36,040
where this thing, where, like, each of this value

1538
01:12:36,040 --> 01:12:38,400
is inside this random variable.

1539
01:12:38,400 --> 01:12:40,840
So, there's, like, purple.

1540
01:12:40,840 --> 01:12:43,640
This HI is, like, your kernel.

1541
01:12:43,640 --> 01:12:46,840
Then, there'll be this CIMA, your color.

1542
01:12:46,840 --> 01:12:49,160
So, it's helping you to understand

1543
01:12:49,160 --> 01:12:52,640
where the paper is fitting inside the fragmented code.

1544
01:12:53,680 --> 01:12:57,920
And, yeah, I think that's it for this paper.

1545
01:12:57,920 --> 01:13:02,920
It's not going to be really hard to understand.

1546
01:13:03,400 --> 01:13:06,560
I think you might have gotten a pretty good idea

1547
01:13:06,560 --> 01:13:07,920
about how we are doing it.

1548
01:13:07,920 --> 01:13:09,480
We have a bunch of weights.

1549
01:13:09,480 --> 01:13:11,560
These weights depend upon how much distance

1550
01:13:11,560 --> 01:13:13,880
is between the current value, like, anything,

1551
01:13:13,880 --> 01:13:16,680
normal, further, anything, right?

1552
01:13:16,680 --> 01:13:19,880
And then, it scales, depending upon exponential,

1553
01:13:19,880 --> 01:13:22,080
so that if two values are too far apart,

1554
01:13:22,080 --> 01:13:23,400
we're going to be in that.

1555
01:13:23,400 --> 01:13:25,040
If the values are close, we're going to be in more.

1556
01:13:25,040 --> 01:13:27,200
That means, like, they are the same thing.

1557
01:13:28,680 --> 01:13:33,680
And, yeah, the deadline for this project is 21st, yeah.

1558
01:13:35,600 --> 01:13:39,200
So, does that mean, like, that, like, iterative,

1559
01:13:39,200 --> 01:13:42,120
you know, go to look at it and apply,

1560
01:13:42,120 --> 01:13:44,600
you know, parse the kernel.

1561
01:13:44,600 --> 01:13:47,040
That's, like, that's just independent

1562
01:13:47,040 --> 01:13:52,040
of the actual parentheses on the weights,

1563
01:13:52,120 --> 01:13:54,160
like, the kernel, like, the, you know,

1564
01:13:54,160 --> 01:13:56,400
the normal and the cognitive position.

1565
01:13:56,400 --> 01:13:57,280
Is that correct?

1566
01:13:57,280 --> 01:13:58,880
Maybe you can give me that question again.

1567
01:13:58,880 --> 01:14:01,320
So, like, when you're, when you're,

1568
01:14:01,320 --> 01:14:04,000
when you are doing the iterative blurring

1569
01:14:04,000 --> 01:14:06,280
with the sparser and sparser matrices,

1570
01:14:06,280 --> 01:14:10,320
that's just an optimization on Gaussian blur, right?

1571
01:14:10,320 --> 01:14:14,280
That is just, like, we can do this denoising

1572
01:14:14,960 --> 01:14:16,240
with a regular Gaussian blur, too.

1573
01:14:16,240 --> 01:14:17,640
Yeah, right, yeah.

1574
01:14:17,640 --> 01:14:22,640
The middle values are just too insignificant to care about.

1575
01:14:23,640 --> 01:14:24,480
The what?

1576
01:14:24,480 --> 01:14:25,880
The values in the middle,

1577
01:14:25,880 --> 01:14:28,720
as you make your portions go larger and larger.

1578
01:14:28,720 --> 01:14:29,560
Yeah.

1579
01:14:29,560 --> 01:14:31,960
The values in the middle are too insignificant,

1580
01:14:31,960 --> 01:14:34,080
like, 0.003 or something.

1581
01:14:34,080 --> 01:14:35,920
So, why waste memory on those?

1582
01:14:35,920 --> 01:14:36,760
Yeah.

1583
01:14:36,760 --> 01:14:39,200
Yeah, I think what Atra might have done was, like,

1584
01:14:39,200 --> 01:14:41,680
use the original 5x5 pixels,

1585
01:14:41,680 --> 01:14:43,360
and then kept on increasing it,

1586
01:14:43,400 --> 01:14:44,880
and then, until it,

1587
01:14:44,880 --> 01:14:47,360
and then, it was largely 16x16,

1588
01:14:47,360 --> 01:14:50,760
and then use the original 16x16 Gaussian blur kernel,

1589
01:14:50,760 --> 01:14:51,760
and see if that,

1590
01:14:51,760 --> 01:14:54,200
and he found that the results were not too different,

1591
01:14:54,200 --> 01:14:59,120
that we, that we can go about just using lesser memory,

1592
01:14:59,120 --> 01:15:01,120
then that's the optimization that we do.

1593
01:15:02,440 --> 01:15:03,440
Does anybody else?

1594
01:15:03,440 --> 01:15:04,320
Yes.

1595
01:15:04,320 --> 01:15:06,480
So, I'm doing this on your,

1596
01:15:08,720 --> 01:15:10,960
these reflections,

1597
01:15:11,000 --> 01:15:11,840
I don't,

1598
01:15:13,840 --> 01:15:15,720
So, let's, let's think about, like,

1599
01:15:15,720 --> 01:15:18,680
what a mirror specular material would be.

1600
01:15:18,680 --> 01:15:22,520
Let's say that there's a specular ball inside,

1601
01:15:22,520 --> 01:15:24,880
or, like, in your scene somewhere,

1602
01:15:24,880 --> 01:15:27,200
and then behind that is the wall,

1603
01:15:27,200 --> 01:15:30,720
as, like, I'm just imagining my corner box scene.

1604
01:15:30,720 --> 01:15:33,120
We have a sphere, we have balls.

1605
01:15:33,120 --> 01:15:37,240
So, when, let's say that there's an edge for the sphere,

1606
01:15:37,240 --> 01:15:38,960
and then there's a wall behind it,

1607
01:15:38,960 --> 01:15:41,600
I just want to know that I don't blur

1608
01:15:41,600 --> 01:15:43,080
the values of the sphere,

1609
01:15:43,080 --> 01:15:45,560
like the reflective values inside the sphere with the wall,

1610
01:15:45,560 --> 01:15:48,160
because if I blur them, that's going to be a problem.

1611
01:15:48,160 --> 01:15:51,720
So, I am going to stop as soon as I find

1612
01:15:51,720 --> 01:15:53,560
that the normal of the sphere is too different

1613
01:15:53,560 --> 01:15:54,960
from the normal of the wall.

1614
01:15:59,600 --> 01:16:00,440
Yeah.

1615
01:16:01,480 --> 01:16:03,640
So, yeah, the reflections will be blurred.

1616
01:16:09,960 --> 01:16:10,800
Oh.

1617
01:16:15,320 --> 01:16:19,600
The reflection, the scene, or the goal of denoising

1618
01:16:19,600 --> 01:16:20,920
is to denoise the whole scene.

1619
01:16:20,920 --> 01:16:23,400
So, even if you have a very defective sphere,

1620
01:16:23,400 --> 01:16:26,520
doesn't mean that you're not going to have a draining wall.

1621
01:16:26,520 --> 01:16:29,040
So, the goal is to get rid of the draining.

1622
01:16:29,040 --> 01:16:31,920
But, as you'll see in project four,

1623
01:16:31,920 --> 01:16:34,480
this is just an introduction to getting started

1624
01:16:34,480 --> 01:16:35,320
with denoising.

1625
01:16:35,320 --> 01:16:38,280
It's not anybody else's great at denoising either.

1626
01:16:38,640 --> 01:16:41,360
So, what it's going to do is it's going to help your scene,

1627
01:16:41,360 --> 01:16:44,000
it's going to help your scene dissolve a lot faster,

1628
01:16:44,000 --> 01:16:47,280
but it will introduce some amount of blur.

1629
01:16:47,280 --> 01:16:50,360
But, ideally, it shouldn't be too bad.

1630
01:16:50,360 --> 01:16:55,360
What, if you run denoising on the first image,

1631
01:16:56,360 --> 01:16:57,640
compared to the hundredth image,

1632
01:16:57,640 --> 01:17:00,320
you're going to get different amounts of blur.

1633
01:17:00,320 --> 01:17:02,480
So, it depends where you balance it out.

1634
01:17:02,480 --> 01:17:05,320
Yeah, so like a perfect example would be,

1635
01:17:06,320 --> 01:17:10,160
yeah, so you see, there's grain here,

1636
01:17:10,160 --> 01:17:13,280
and then there's also graininess on the reflective material.

1637
01:17:13,280 --> 01:17:14,840
It's the same, right?

1638
01:17:14,840 --> 01:17:18,360
If I blur my, let's say, the ground,

1639
01:17:18,360 --> 01:17:19,520
I should also blur this,

1640
01:17:19,520 --> 01:17:22,320
because the reflection should be the same, right?

1641
01:17:22,320 --> 01:17:24,760
Like, it should show me the same image,

1642
01:17:24,760 --> 01:17:27,600
where I'm like the same values that I'm seeing here,

1643
01:17:27,600 --> 01:17:28,760
like for the color.

1644
01:17:28,760 --> 01:17:32,240
If I blur this out, then that should also be blurred, right?

1645
01:17:32,560 --> 01:17:37,560
So, yeah, that's why we should blur the whole image.

1646
01:17:37,840 --> 01:17:40,800
I'm not saying that the results are going to be great.

1647
01:17:40,800 --> 01:17:43,640
It's going to be like a very bad result.

1648
01:17:43,640 --> 01:17:44,480
Let me show you.

1649
01:17:47,720 --> 01:17:50,120
Yeah, you see, it's not that good.

1650
01:17:50,120 --> 01:17:53,120
Like now the reflection, it's all blurred out of the sphere.

1651
01:17:57,040 --> 01:17:59,040
Yeah, you can't see it clearly right now.

1652
01:17:59,040 --> 01:18:00,920
It doesn't look that bad.

1653
01:18:00,920 --> 01:18:05,920
So I think this was, yeah, this paper is like for us

1654
01:18:06,080 --> 01:18:08,400
to understand how denoising actually works,

1655
01:18:08,400 --> 01:18:10,160
like how it started off.

1656
01:18:10,160 --> 01:18:14,480
Now there's like, now we also have like neural networks,

1657
01:18:14,480 --> 01:18:18,560
and that's what will do the denoising of the sphere.

1658
01:18:19,720 --> 01:18:24,720
So what I understand, basically we identify the portion.

1659
01:18:25,720 --> 01:18:28,720
Is this done in screen space, or is this done?

1660
01:18:28,720 --> 01:18:32,160
We like using the g-buffer.

1661
01:18:32,160 --> 01:18:34,520
Yeah, so in the g-buffer, right?

1662
01:18:34,520 --> 01:18:36,840
Like per pixel, we know something,

1663
01:18:36,840 --> 01:18:38,880
we know its position, we know it's normal,

1664
01:18:38,880 --> 01:18:39,920
we know its color.

1665
01:18:41,360 --> 01:18:45,240
And based on this screen space information,

1666
01:18:45,240 --> 01:18:49,800
we are segmenting the image into discrete elements

1667
01:18:49,800 --> 01:18:54,240
that would apply a specific color to the image.

1668
01:18:54,640 --> 01:18:57,240
So this is a big Gaussian blur at the end.

1669
01:18:58,560 --> 01:19:00,840
Yeah, so like, you know,

1670
01:19:00,840 --> 01:19:04,480
because instead of applying it to the entire screen,

1671
01:19:04,480 --> 01:19:08,840
okay, this is a wall, that wall is like that wall,

1672
01:19:08,840 --> 01:19:10,400
but not other parts.

1673
01:19:12,400 --> 01:19:16,880
And then if you get to an edge, like what happens?

1674
01:19:16,880 --> 01:19:17,720
Like if you're on-

1675
01:19:17,720 --> 01:19:20,280
No, it's exactly like, let's say that.

1676
01:19:20,280 --> 01:19:24,120
So this is the blur that we see in the glossy blur,

1677
01:19:25,000 --> 01:19:26,560
randomly, like an image.

1678
01:19:26,560 --> 01:19:28,600
This is not what we're gonna get.

1679
01:19:28,600 --> 01:19:31,560
But if you do it with the edge of it,

1680
01:19:31,560 --> 01:19:33,520
what's gonna do it, it's gonna stop.

1681
01:19:33,520 --> 01:19:35,960
So let's say that this is the pixel that I'm operating on,

1682
01:19:35,960 --> 01:19:39,200
like this whole thing, this whole patch.

1683
01:19:39,200 --> 01:19:42,720
So I found that the normals of this wall

1684
01:19:42,720 --> 01:19:45,360
was like really different, and even the color.

1685
01:19:45,360 --> 01:19:48,880
So when I was weighing this pixel inside my Gaussian,

1686
01:19:48,880 --> 01:19:50,760
which I'm applying with formula,

1687
01:19:50,760 --> 01:19:54,920
I weighed it down, like the weight is like two less now

1688
01:19:54,920 --> 01:19:56,520
for the Gaussian blur to come into effect,

1689
01:19:56,520 --> 01:19:58,640
because these two values are too far apart.

1690
01:19:58,640 --> 01:20:01,280
Oh, so literally like,

1691
01:20:01,280 --> 01:20:04,840
because we have a, what, like a 16 by 16 window, right?

1692
01:20:04,840 --> 01:20:05,920
So let's say we have the pic,

1693
01:20:05,920 --> 01:20:09,600
we're trying to calculate, you know, the value,

1694
01:20:09,600 --> 01:20:13,560
the RGB value of, you know, a pixel that's right on the edge.

1695
01:20:13,560 --> 01:20:16,920
When we do our weird Gaussian blur,

1696
01:20:17,040 --> 01:20:19,600
when we do the pyramid,

1697
01:20:19,600 --> 01:20:24,520
we will evaluate a pixel that's on like a different wall.

1698
01:20:24,520 --> 01:20:27,600
But because that wall has a different normal value

1699
01:20:27,600 --> 01:20:30,320
and different color and like a different position,

1700
01:20:30,320 --> 01:20:31,520
we're gonna squish,

1701
01:20:31,520 --> 01:20:33,960
like it already has like a Gaussian kernel weight.

1702
01:20:33,960 --> 01:20:36,040
We also have another thing that we like,

1703
01:20:36,040 --> 01:20:37,800
because it's so different from our current thing,

1704
01:20:37,800 --> 01:20:41,080
we squish it down and therefore, yeah.

1705
01:20:41,080 --> 01:20:42,800
And I'm just gonna like,

1706
01:20:42,800 --> 01:20:45,000
for you guys to understand it better,

1707
01:20:45,040 --> 01:20:48,160
I'm just gonna do some calculation here really quick.

1708
01:20:48,160 --> 01:20:51,120
So let's say that this is the pixel of the red wall

1709
01:20:51,120 --> 01:20:53,040
that I'm trying to find out.

1710
01:20:53,040 --> 01:20:57,120
So, and my formula, it's like a formula,

1711
01:20:57,120 --> 01:20:59,640
which is gonna, let's say my filter is like five by five,

1712
01:20:59,640 --> 01:21:00,560
right?

1713
01:21:00,560 --> 01:21:04,600
So I'm gonna do like a four I equals to zero,

1714
01:21:04,600 --> 01:21:07,200
and which is like I less than 25,

1715
01:21:07,200 --> 01:21:09,360
because this is my five by five thing.

1716
01:21:09,360 --> 01:21:11,160
And this is,

1717
01:21:15,000 --> 01:21:20,000
this is my Gaussian kernel,

1718
01:21:22,120 --> 01:21:24,800
which is like some values here.

1719
01:21:26,040 --> 01:21:27,600
And then this is my center value.

1720
01:21:27,600 --> 01:21:29,080
So this is gonna be the largest.

1721
01:21:29,080 --> 01:21:30,960
I don't know what the value is.

1722
01:21:30,960 --> 01:21:32,920
Like let's say it's 0.02.

1723
01:21:32,920 --> 01:21:35,200
And all the values are smaller than that.

1724
01:21:35,200 --> 01:21:39,840
So my color value, I started like zero.

1725
01:21:39,840 --> 01:21:42,320
And then color is just like an additive thing

1726
01:21:42,320 --> 01:21:43,160
in this for loop.

1727
01:21:43,160 --> 01:21:45,640
So plus equal to my function.

1728
01:21:45,640 --> 01:21:49,600
This function is just gonna return me this A true value,

1729
01:21:49,600 --> 01:21:51,520
which is like some weights multiplied.

1730
01:21:51,520 --> 01:21:56,520
So this function is weight multiplied

1731
01:21:56,560 --> 01:21:58,440
by the Gaussian kernel,

1732
01:21:58,440 --> 01:22:02,000
multiplied by the color of my current pixel, right?

1733
01:22:03,200 --> 01:22:04,280
Yeah.

1734
01:22:04,280 --> 01:22:07,520
So Gaussian blur, we divide by K,

1735
01:22:07,520 --> 01:22:12,320
being the number of weights that are being emitted.

1736
01:22:12,320 --> 01:22:14,840
But if we do divide by K,

1737
01:22:14,840 --> 01:22:16,440
that assumes like equal weight

1738
01:22:16,440 --> 01:22:20,000
from each participating, like neighbor.

1739
01:22:20,000 --> 01:22:25,000
Like if our weight squeezes down different pixels

1740
01:22:25,480 --> 01:22:27,240
down to like zero,

1741
01:22:27,240 --> 01:22:30,240
but we're still giving people weight when they agree.

1742
01:22:31,400 --> 01:22:34,240
No, so what's happening essentially is,

1743
01:22:34,240 --> 01:22:37,440
when you have the edge between the red and the white.

1744
01:22:37,440 --> 01:22:39,040
In screen space, you're gonna be working

1745
01:22:39,040 --> 01:22:41,000
on both the red and the white pixels.

1746
01:22:41,000 --> 01:22:42,160
Yeah.

1747
01:22:43,000 --> 01:22:44,640
But because of the weights,

1748
01:22:44,640 --> 01:22:48,440
the reds are gonna have more weight than the whites.

1749
01:22:48,440 --> 01:22:49,280
Yeah.

1750
01:22:49,280 --> 01:22:52,480
So you don't darken your image in that sense.

1751
01:22:54,120 --> 01:22:57,000
The intensity doesn't decrease the intensity.

1752
01:22:57,000 --> 01:22:58,360
You may get a little bit of blur,

1753
01:22:58,360 --> 01:23:01,320
but not decrease in intensity.

1754
01:23:01,320 --> 01:23:03,560
My main concern is just like,

1755
01:23:07,840 --> 01:23:10,240
so all that's being affected actually

1756
01:23:10,240 --> 01:23:13,600
is the kernel weight, right?

1757
01:23:13,600 --> 01:23:15,000
Not the intensity.

1758
01:23:15,000 --> 01:23:16,400
No, I get your question.

1759
01:23:16,400 --> 01:23:19,240
So I'll explain that why that wouldn't happen.

1760
01:23:19,240 --> 01:23:20,320
So let me go through this.

1761
01:23:20,320 --> 01:23:21,160
So yeah.

1762
01:23:21,160 --> 01:23:23,520
So let's say that the weight for,

1763
01:23:29,960 --> 01:23:31,080
Yeah.

1764
01:23:31,080 --> 01:23:33,840
So when I calculated the weight for,

1765
01:23:33,840 --> 01:23:35,920
let's say this is my pixel that I'm trying to find in,

1766
01:23:35,920 --> 01:23:39,120
the weight for this one is like, let's say 0.9.

1767
01:23:39,600 --> 01:23:41,760
Nice weight, very high weight, right?

1768
01:23:41,760 --> 01:23:44,880
So, and when I added this value inside this color,

1769
01:23:44,880 --> 01:23:46,040
it's gonna be like huge,

1770
01:23:46,040 --> 01:23:48,440
because I know that it's like closer.

1771
01:23:48,440 --> 01:23:50,880
When I calculated the weight for this white wall,

1772
01:23:50,880 --> 01:23:54,440
it came out to be 0.001.

1773
01:23:54,440 --> 01:23:57,640
So that's why this color never get blended in,

1774
01:23:57,640 --> 01:23:59,120
inside my pixel.

1775
01:23:59,120 --> 01:24:01,200
So that's how the edge detection works,

1776
01:24:01,200 --> 01:24:03,080
because I didn't blur this value,

1777
01:24:03,080 --> 01:24:06,480
like this red will never have a white blurred into it.

1778
01:24:06,480 --> 01:24:08,440
So that's why, that's how it stopped.

1779
01:24:08,480 --> 01:24:10,000
Now to come back to your question,

1780
01:24:10,000 --> 01:24:13,240
where you were saying that if I didn't end up

1781
01:24:13,240 --> 01:24:14,720
taking some of the pixel values,

1782
01:24:14,720 --> 01:24:17,880
that means when I'm dividing everything.

1783
01:24:17,880 --> 01:24:21,880
So this pixel, because it took all of the pixels

1784
01:24:21,880 --> 01:24:23,920
surrounding it, then density will be higher,

1785
01:24:23,920 --> 01:24:25,920
because I'm dividing by like, let's say K.

1786
01:24:25,920 --> 01:24:28,640
But this one, it never took these pixels.

1787
01:24:28,640 --> 01:24:33,480
And for this one, it ended up taking all the 25 values

1788
01:24:33,480 --> 01:24:34,880
by the size of it.

1789
01:24:34,880 --> 01:24:37,000
This one never took all the values, right?

1790
01:24:37,000 --> 01:24:38,840
It just took, let's say, 15.

1791
01:24:38,840 --> 01:24:40,320
And all the values on the right side,

1792
01:24:40,320 --> 01:24:43,520
this white wall never came into play for the final color.

1793
01:24:43,520 --> 01:24:46,120
That means that the final color value will be less,

1794
01:24:46,120 --> 01:24:48,040
and that's what I don't want.

1795
01:24:48,040 --> 01:24:53,040
So when we see the formula, yeah.

1796
01:24:53,880 --> 01:24:57,520
So the K value here, which is like the mean of my thing,

1797
01:24:57,520 --> 01:25:02,200
is this thing, which is like HI and then the W.

1798
01:25:02,200 --> 01:25:03,880
So if I'm dividing by,

1799
01:25:03,880 --> 01:25:06,120
so if I'm adding something like 0.01,

1800
01:25:06,120 --> 01:25:07,320
which is like two less,

1801
01:25:07,320 --> 01:25:11,400
but then I'm also like dividing it by some value,

1802
01:25:11,400 --> 01:25:13,360
which is like lower,

1803
01:25:13,360 --> 01:25:15,200
then the whole thing is going to go up.

1804
01:25:15,200 --> 01:25:16,520
K is not constant.

1805
01:25:16,520 --> 01:25:19,280
Yeah, K is not constant, K is same.

1806
01:25:19,280 --> 01:25:21,440
Does anybody understand that?

1807
01:25:21,440 --> 01:25:24,520
We'll go to the third for the moment.

1808
01:25:36,360 --> 01:25:37,440
Oh, I see it.

1809
01:25:58,560 --> 01:26:00,480
That's happening at the last part,

1810
01:26:00,480 --> 01:26:03,800
so I'm dividing by the sum of the cells.

1811
01:26:06,120 --> 01:26:06,960
Oh, yeah.

1812
01:26:18,440 --> 01:26:22,880
Oh, we're not even.

1813
01:26:29,800 --> 01:26:30,880
We're scaling.

1814
01:26:31,840 --> 01:26:32,680
Oh.

1815
01:26:34,320 --> 01:26:35,160
Just kidding.

1816
01:26:35,160 --> 01:26:37,160
Who's name do you have?

1817
01:26:37,160 --> 01:26:39,560
It's like, if he doesn't, he would.

1818
01:26:39,560 --> 01:26:40,400
Yeah.

1819
01:26:40,400 --> 01:26:42,600
It's kernel, like kernel is the Gaussian.

1820
01:26:42,600 --> 01:26:44,000
Yeah.

1821
01:26:44,000 --> 01:26:49,000
So we're just scaling, also scaling the kernel values.

1822
01:26:50,320 --> 01:26:51,920
Yeah, so this is like one equation.

1823
01:26:51,920 --> 01:26:55,280
Don't think about this like, this is one equation.

1824
01:26:55,280 --> 01:26:57,600
It's like 425 by 25.

1825
01:26:57,600 --> 01:27:01,840
I haven't expanded my kernel here.

1826
01:27:01,840 --> 01:27:05,920
So the formula there, like for I go to zero to become 25,

1827
01:27:05,920 --> 01:27:09,200
I take in 25 pixels surrounding me and I do that.

1828
01:27:09,200 --> 01:27:12,280
There's going to be next iteration of the same code,

1829
01:27:12,280 --> 01:27:14,200
which is going to do this 25 again,

1830
01:27:14,200 --> 01:27:16,280
but now the options will be different,

1831
01:27:16,280 --> 01:27:18,280
for like the pixel position that I'm in.

1832
01:27:28,600 --> 01:27:33,600
So offsets, so it's uniform deck two,

1833
01:27:34,280 --> 01:27:37,960
it's an array of 25 deck twos, correct?

1834
01:27:37,960 --> 01:27:38,800
Yeah.

1835
01:27:38,800 --> 01:27:41,600
So for the corner ones, it would be like plus one,

1836
01:27:41,600 --> 01:27:43,280
plus one, plus one, minus one.

1837
01:27:43,280 --> 01:27:44,120
Yeah.

1838
01:27:44,120 --> 01:27:46,440
It depends on the power of the iteration, I think.

1839
01:27:46,440 --> 01:27:47,760
Yeah.

1840
01:27:47,760 --> 01:27:49,080
Two power n minus one, right?

1841
01:27:49,080 --> 01:27:50,080
So yeah, n minus one.

1842
01:27:50,080 --> 01:27:53,440
So what's written in the paper is like this,

1843
01:27:53,440 --> 01:27:55,760
like line minus, it can be very confusing,

1844
01:27:55,920 --> 01:27:58,840
but so it says that at each level,

1845
01:27:58,840 --> 01:27:59,800
i is greater than zero,

1846
01:27:59,800 --> 01:28:02,320
the filter doubles its extent by filling in

1847
01:28:02,320 --> 01:28:04,160
two to the power i minus one zero

1848
01:28:04,160 --> 01:28:06,120
between the initial entry.

1849
01:28:06,120 --> 01:28:08,120
So what it's doing is like,

1850
01:28:08,120 --> 01:28:11,760
so for the first iteration,

1851
01:28:11,760 --> 01:28:15,280
like so what we have is two to the power of one minus one,

1852
01:28:15,280 --> 01:28:17,000
zero, one, so one, one, one, one, one.

1853
01:28:17,000 --> 01:28:19,280
So everything we have like between every pixel

1854
01:28:19,280 --> 01:28:21,160
there's like one.

1855
01:28:21,160 --> 01:28:22,320
And that's like, yeah.

1856
01:28:22,360 --> 01:28:25,240
And do we have like two,

1857
01:28:25,240 --> 01:28:26,080
yeah.

1858
01:28:26,080 --> 01:28:26,920
And then between these two,

1859
01:28:26,920 --> 01:28:28,800
there's like two, and two, and two,

1860
01:28:28,800 --> 01:28:31,000
between every pixel.

1861
01:28:31,000 --> 01:28:34,680
Or is it like three, but it doesn't matter.

1862
01:28:36,880 --> 01:28:38,320
Oh.

1863
01:28:38,320 --> 01:28:40,520
So you're drawing like a problem.

1864
01:28:40,520 --> 01:28:41,360
Yeah.

1865
01:28:42,480 --> 01:28:43,320
Or I might be wrong,

1866
01:28:43,320 --> 01:28:45,760
because I checked the paper exactly,

1867
01:28:45,760 --> 01:28:47,080
because it's like some problem,

1868
01:28:47,080 --> 01:28:49,840
you just increase your step with every iteration

1869
01:28:49,840 --> 01:28:51,160
by a certain amount,

1870
01:28:51,160 --> 01:28:52,640
which is really depends upon

1871
01:28:52,640 --> 01:28:54,480
two to the power of five minus one.

1872
01:28:54,480 --> 01:28:55,920
That's what the paper tells.

1873
01:28:56,920 --> 01:28:57,760
Yeah.

1874
01:28:57,760 --> 01:28:58,760
And then you just apply with that.

1875
01:28:58,760 --> 01:29:02,480
And how many times you're going to do that same iteration

1876
01:29:02,480 --> 01:29:03,920
with like increasing step rate,

1877
01:29:03,920 --> 01:29:05,680
is like for you to find out,

1878
01:29:05,680 --> 01:29:06,520
like just see.

1879
01:29:09,000 --> 01:29:11,120
I think there's a value that's given in the paper.

1880
01:29:11,120 --> 01:29:13,040
I'm not entirely sure what I used,

1881
01:29:13,040 --> 01:29:14,560
but there's like,

1882
01:29:14,560 --> 01:29:15,800
I was going through my comments

1883
01:29:15,800 --> 01:29:17,240
and there was like this line that

1884
01:29:17,240 --> 01:29:18,680
I found this value to be perfect.

1885
01:29:18,680 --> 01:29:20,080
Now I don't remember

1886
01:29:20,080 --> 01:29:21,280
how I reached to that value.

1887
01:29:21,280 --> 01:29:22,600
Was it like this file in there?

1888
01:29:22,600 --> 01:29:23,440
I don't know.

1889
01:29:23,440 --> 01:29:24,280
I found it somewhere.

1890
01:29:24,280 --> 01:29:25,960
I just played around with it.

1891
01:29:25,960 --> 01:29:28,480
But yeah, just like that.

1892
01:29:28,480 --> 01:29:30,840
So does anybody else have any questions

1893
01:29:30,840 --> 01:29:34,040
regarding this project, the implementation?

1894
01:29:34,040 --> 01:29:36,280
Everybody got a good idea?

1895
01:29:36,280 --> 01:29:37,840
My work is done, I think.

1896
01:29:42,480 --> 01:29:44,800
Let's do, let's take a break.

1897
01:29:44,800 --> 01:29:46,400
We'll get some lunch at 7 p.m. sharp

1898
01:29:46,400 --> 01:29:48,840
and we'll get started with all the topics.

1899
01:29:48,840 --> 01:29:49,680
Okay.

1900
01:29:50,520 --> 01:29:51,360
Okay.

1901
01:29:53,800 --> 01:29:56,600
Do we have to talk about the extra thing now?

1902
01:29:56,600 --> 01:29:57,840
The extra credits?

1903
01:29:57,840 --> 01:29:58,680
Like-

1904
01:29:58,680 --> 01:29:59,520
No, it's all there.

1905
01:29:59,520 --> 01:30:00,360
Yeah, it's all there.

1906
01:30:00,360 --> 01:30:01,200
Yeah.

1907
01:30:01,200 --> 01:30:02,240
We can take a look at it.

1908
01:30:02,240 --> 01:30:03,200
Okay.

1909
01:30:03,200 --> 01:30:05,280
Thank you, Professor Shehlan.

1910
01:30:05,280 --> 01:30:06,600
That's so good.

1911
01:32:20,080 --> 01:32:21,080
Okay.

1912
01:32:50,920 --> 01:32:51,760
Okay.

1913
01:33:01,760 --> 01:33:02,600
I have,

1914
01:33:03,640 --> 01:33:05,880
I reached out to my client.

1915
01:33:05,880 --> 01:33:06,880
So it's like this.

1916
01:33:06,880 --> 01:33:07,720
Yeah.

1917
01:33:08,240 --> 01:33:10,240
I want to talk about it.

1918
01:33:19,120 --> 01:33:19,960
I agree.

1919
01:33:19,960 --> 01:33:20,800
I agree.

1920
01:33:37,720 --> 01:33:38,560
I agree.

1921
01:33:56,080 --> 01:33:58,960
Oh, thanks to you, because I haven't created it.

1922
01:33:58,960 --> 01:33:59,800
Oh, okay.

1923
01:33:59,800 --> 01:34:01,800
And I thought you forgot, I read your email.

1924
01:34:01,800 --> 01:34:03,400
Thank you for that.

1925
01:34:07,720 --> 01:34:09,080
Okay.

1926
01:34:37,720 --> 01:35:00,020
Okay.

1927
01:35:30,020 --> 01:35:49,520
I'm going to 

1928
01:35:49,520 --> 01:35:57,140
That was it.

1929
01:36:27,140 --> 01:36:49,780
All right, so we saw deferred rendering in the first part of the lecture, right, where

1930
01:36:49,780 --> 01:36:57,900
what we did was we separated the geometry and the material from the lighting computation.

1931
01:36:57,900 --> 01:37:03,500
Essentially, we stored all the rasterization outputs, and then we ran all the lighting

1932
01:37:03,500 --> 01:37:04,500
stuff.

1933
01:37:04,500 --> 01:37:08,100
So it kind of broke it into two parts.

1934
01:37:08,100 --> 01:37:14,500
What we're going to see with ForwardPlus and Clustered is another way to optimize our

1935
01:37:14,500 --> 01:37:19,340
standard rendering pipeline, but doing it in a different way.

1936
01:37:19,340 --> 01:37:21,340
So let's take a look at that.

1937
01:37:21,340 --> 01:37:26,900
So as a reminder, deferred shading has a few limitations.

1938
01:37:26,900 --> 01:37:32,320
It has a very high memory bandwidth because of reading that GBuffer over and over again.

1939
01:37:32,320 --> 01:37:37,060
You can't do too many materials, for example, you can't do translucency.

1940
01:37:37,060 --> 01:37:42,820
You can't do MS or you can't easily do MSA because as soon as you want to do multi-sample

1941
01:37:43,820 --> 01:37:49,740
are quadrupling, if not more, the size of your GBuffer.

1942
01:37:49,740 --> 01:37:54,620
And there's still some redundant lighting computation where there are lighting overlaps

1943
01:37:54,620 --> 01:38:03,580
or towards the edge of the influence, you have very low weights and stuff like that.

1944
01:38:03,580 --> 01:38:06,440
So how do we optimize this further?

1945
01:38:06,440 --> 01:38:19,160
So just as a recap, the deferred shading is for each light, you're computing the visibility,

1946
01:38:19,160 --> 01:38:27,360
storing it in a GBuffer, and then all of these have to be read again and again, right?

1947
01:38:27,360 --> 01:38:38,160
So that's where you have the overdraw essentially for each light.

1948
01:38:38,160 --> 01:38:44,480
And then at the bottom, so that's the traditional deferred, and this is the tile deferred at

1949
01:38:44,480 --> 01:38:52,200
the bottom where we are changing it into, okay, we only do it per tile and see which

1950
01:38:52,200 --> 01:38:57,000
lights are influencing which tile and then do it that way.

1951
01:38:57,640 --> 01:39:02,760
So another way to look at this is in 3D as one, okay?

1952
01:39:02,760 --> 01:39:07,320
So can everybody see this camera here?

1953
01:39:07,320 --> 01:39:11,920
Think of this as a virtual camera, okay?

1954
01:39:11,920 --> 01:39:14,440
These blue are tiles, right?

1955
01:39:14,440 --> 01:39:21,240
In 2D when you have like your screen here, these are tiles and they're starting from

1956
01:39:21,240 --> 01:39:25,000
the first point of intersection, there's a tree here by the way.

1957
01:39:25,160 --> 01:39:27,320
First point of intersection going all the way back.

1958
01:39:28,040 --> 01:39:29,320
Let me turn down the lights.

1959
01:39:35,320 --> 01:39:43,560
What we get is you see that where there's no intersections, it's hitting the wall and

1960
01:39:43,560 --> 01:39:45,240
you see the checker pattern back there.

1961
01:39:46,120 --> 01:39:51,160
And wherever it's hitting, it's going through these spheres of influence of light.

1962
01:39:51,160 --> 01:39:54,280
These spheres represent the lights as going through that.

1963
01:39:55,960 --> 01:40:05,240
So what you get is the tree in the front, so this tree here is actually doing a lot

1964
01:40:05,240 --> 01:40:07,000
of occlusion, okay?

1965
01:40:07,000 --> 01:40:08,600
It's blocking a lot of the lights.

1966
01:40:09,720 --> 01:40:12,520
None of these lights are actually affecting this tree here.

1967
01:40:14,040 --> 01:40:19,480
But the 2D tiling, so in deferred we had that 2D tiling, right?

1968
01:40:19,480 --> 01:40:21,560
Which I showed you in the sponsor scene.

1969
01:40:22,200 --> 01:40:24,200
It doesn't take that into account.

1970
01:40:24,280 --> 01:40:30,360
It doesn't take into account that all the lights are behind the tree here and a lot

1971
01:40:30,360 --> 01:40:31,320
of it is occluded.

1972
01:40:32,040 --> 01:40:34,200
So it's not taking that z value into space.

1973
01:40:35,240 --> 01:40:37,000
Another way to look at it is like this.

1974
01:40:37,560 --> 01:40:42,200
So these lights are the spheres of influence of the light and then we have this tree here,

1975
01:40:42,920 --> 01:40:43,560
okay?

1976
01:40:43,560 --> 01:40:49,000
And like only like two tiles affect like all six of them.

1977
01:40:49,640 --> 01:40:57,000
So only some of the pixels are from the tree, which are not influenced by any light.

1978
01:40:58,520 --> 01:41:04,680
But the tile, these two tiles here, these two blue tiles, they intersect with all six

1979
01:41:04,680 --> 01:41:05,080
lights.

1980
01:41:05,720 --> 01:41:13,000
And likewise, the pixels in the times are at the very back of the scene are only influenced

1981
01:41:13,000 --> 01:41:14,040
by two lights.

1982
01:41:14,040 --> 01:41:17,240
And that is this back here, okay?

1983
01:41:17,880 --> 01:41:22,600
So that's kind of the problem with deferred rendering is that it doesn't take all of this

1984
01:41:23,400 --> 01:41:25,160
3D space into account.

1985
01:41:26,600 --> 01:41:30,840
So let's see how what we call ForwardPlus helps solve that.

1986
01:41:32,200 --> 01:41:39,160
So ForwardPlus does light culling for screen space tiles and it's designed for modern day

1987
01:41:39,160 --> 01:41:39,800
GPUs.

1988
01:41:39,800 --> 01:41:46,280
It understands how, just like we've learned in this class about how CUDA has helped optimize

1989
01:41:46,280 --> 01:41:49,480
GPUs and the various things we should be taking into account.

1990
01:41:49,480 --> 01:41:53,560
It takes those kinds of things into account to help optimize the rendering pipeline.

1991
01:41:53,560 --> 01:41:58,840
And two of those things are a high computer memory ratio, which means computers free,

1992
01:41:58,840 --> 01:42:01,960
memory is expensive, and compute shaders.

1993
01:42:01,960 --> 01:42:06,600
So essentially what you've done in CUDA, translate that into a rendering pipeline and you get

1994
01:42:06,600 --> 01:42:07,480
compute shaders.

1995
01:42:08,520 --> 01:42:12,040
So ForwardPlus has three passes.

1996
01:42:13,000 --> 01:42:19,080
It has first a depth pass or a Z pre-pass as it's called, it has light culling, and

1997
01:42:19,080 --> 01:42:20,360
then it has a final shading.

1998
01:42:21,080 --> 01:42:22,840
How many passes did deferred have?

1999
01:42:24,520 --> 01:42:26,040
How many phases did deferred have?

2000
01:42:27,080 --> 01:42:27,800
Two, right?

2001
01:42:27,800 --> 01:42:31,560
It had generate the G-buffer, do the lighting calculations.

2002
01:42:33,160 --> 01:42:35,000
So in time we have three.

2003
01:42:35,000 --> 01:42:36,200
So let's see how this works.

2004
01:42:36,440 --> 01:42:43,560
So in the first step, in the first phase, we want to have the depth buffer, okay?

2005
01:42:43,560 --> 01:42:47,560
So what we're going to have is essentially what is called a pass-through fragment shader

2006
01:42:47,560 --> 01:42:51,800
where you're getting the depth buffer from the rasterizer, the fragment shader doesn't

2007
01:42:51,800 --> 01:42:54,920
do anything except write the depth buffer to a texture.

2008
01:42:54,920 --> 01:42:57,240
That's what a pass-through fragment shader is.

2009
01:42:57,240 --> 01:42:59,400
Very simple, no lighting evaluator.

2010
01:42:59,960 --> 01:43:05,560
If a fragment shader discards during the light accumulation, that still needs to be

2011
01:43:05,560 --> 01:43:06,280
accounted for.

2012
01:43:07,880 --> 01:43:14,360
So what we are essentially doing is a very standard depth pass and part of the input

2013
01:43:15,240 --> 01:43:16,360
to the light culling pass.

2014
01:43:16,360 --> 01:43:19,960
So this is one of the inputs that will be used in the light culling, which is phase

2015
01:43:19,960 --> 01:43:20,440
two.

2016
01:43:21,480 --> 01:43:27,480
So in this part, what we're going to do is we're going to have a fragment shader, which

2017
01:43:27,480 --> 01:43:32,840
in this part, what we're going to do is compute the lights that overlap each time.

2018
01:43:33,400 --> 01:43:39,400
Just like we had tiles in deferred rendering, in the deferred shading pipeline, we still

2019
01:43:39,400 --> 01:43:41,480
have those tiles in Power+.

2020
01:43:41,480 --> 01:43:43,000
We're not getting rid of those.

2021
01:43:43,000 --> 01:43:46,520
So that's why this image and this image, both appear very blocky.

2022
01:43:47,880 --> 01:43:53,400
The white parts of these images are more lights, the darker parts are less lights.

2023
01:43:54,200 --> 01:44:01,160
The red parts in this image are more overlapping lights, and the black parts are less overlapping

2024
01:44:01,160 --> 01:44:01,720
lights.

2025
01:44:01,720 --> 01:44:03,160
OK, everybody clear on this?

2026
01:44:05,960 --> 01:44:11,960
So what we are essentially trying to do is figure out where there is more light computation

2027
01:44:11,960 --> 01:44:15,240
when there's no light computation needed per tile.

2028
01:44:17,720 --> 01:44:20,040
So let's take an example.

2029
01:44:20,680 --> 01:44:24,920
We have this very simple scene here that is tiled.

2030
01:44:24,920 --> 01:44:28,760
OK, again, very simple, only for representation.

2031
01:44:30,040 --> 01:44:32,520
And let's say we have these three lights.

2032
01:44:34,760 --> 01:44:40,760
For this tile here, only light one has an influence, and even that is very fleeting.

2033
01:44:42,520 --> 01:44:47,880
For this box here, one, two, and three all have a strong influence on that light.

2034
01:44:48,440 --> 01:44:53,480
And then for this box here, two and three have not even to the center, but maybe like

2035
01:44:53,480 --> 01:44:55,720
a quarter of the tile is influenced.

2036
01:44:57,320 --> 01:45:02,360
So what we want to figure out is which tiles, and all of these are the tiles, by the way,

2037
01:45:02,360 --> 01:45:06,120
which are not covered by the orange, are not affected by these lights.

2038
01:45:08,120 --> 01:45:14,840
So what we want to do in our scene is figure out the exact points at which the light influence

2039
01:45:14,840 --> 01:45:15,880
starts and stops.

2040
01:45:16,040 --> 01:45:17,720
So the way to do that is this.

2041
01:45:19,240 --> 01:45:20,920
We do this in a compute shader.

2042
01:45:20,920 --> 01:45:25,560
So the easiest way to think of a compute shader is imagine a CUDA kernel inside a rendering

2043
01:45:25,560 --> 01:45:26,600
pipeline.

2044
01:45:26,600 --> 01:45:28,920
So you can do different types of computation in.

2045
01:45:31,400 --> 01:45:36,760
So now what we are going to do is, if this is our scene where our camera is down here

2046
01:45:36,760 --> 01:45:42,120
and it's expanding that way, so camera down here, depth max here, we're going to input

2047
01:45:42,200 --> 01:45:49,720
the Z-buffer, which we computed in our first path, the depth buffer, and we're going to

2048
01:45:49,720 --> 01:45:54,040
pass a light buffer, which is a shader object.

2049
01:45:56,680 --> 01:45:59,880
And then the output is going to be another list.

2050
01:45:59,880 --> 01:46:02,440
So this is what we're going to do.

2051
01:46:02,440 --> 01:46:08,920
This, where 9 is going like this, that's coming from the depth buffer.

2052
01:46:09,800 --> 01:46:15,560
That's showing you a top-down view of what the depth buffer might be looking like in

2053
01:46:15,560 --> 01:46:17,560
a cross-section, not in 3D, this is in 2D.

2054
01:46:20,040 --> 01:46:26,760
So instead of having a tile represent this entire thing, which we were doing before in

2055
01:46:26,760 --> 01:46:32,840
default shading, where the light started here or the tile started at minimum and went to

2056
01:46:32,840 --> 01:46:36,280
maximum, we're going to change that a little bit.

2057
01:46:37,160 --> 01:46:43,640
We are going to do it using the depth buffer and compute the minimum and maximum in each

2058
01:46:43,640 --> 01:46:45,800
tile in the depth buffer itself.

2059
01:46:46,840 --> 01:46:53,640
So each one of these is a top-down view of a tile, each one of these tiles.

2060
01:46:54,200 --> 01:47:01,960
So the light coming list here, the output for this tile will start from here and end

2061
01:47:01,960 --> 01:47:02,200
here.

2062
01:47:03,000 --> 01:47:05,080
For this tile, it will start here and end here.

2063
01:47:06,040 --> 01:47:11,160
For the third one, it will start here, or technically start here because there's a gap.

2064
01:47:11,160 --> 01:47:13,880
So you can have different objects forward and back.

2065
01:47:13,880 --> 01:47:17,240
So it will start here and end here, and so on and so on.

2066
01:47:19,720 --> 01:47:20,840
Is this clear to everybody?

2067
01:47:20,840 --> 01:47:25,640
Because this part is important about how we are creating this.

2068
01:47:26,600 --> 01:47:34,600
We are using a compute shader to figure out the minimum depth and the maximum depth in

2069
01:47:34,600 --> 01:47:35,160
each tile.

2070
01:47:36,040 --> 01:47:37,480
That's essentially the crux of it.

2071
01:47:39,240 --> 01:47:44,520
In 3D, this would be squares, squares and you're going to get volumes in the back.

2072
01:47:46,200 --> 01:47:48,280
But the depth stuff will remain.

2073
01:47:48,280 --> 01:47:50,840
The depth is still minimum z and maximum z.

2074
01:47:51,880 --> 01:47:53,000
That doesn't change.

2075
01:47:53,320 --> 01:47:54,200
That doesn't change.

2076
01:47:55,400 --> 01:47:56,440
Any questions on this?

2077
01:48:03,880 --> 01:48:09,080
So the way to do this is you do one-third per pixel.

2078
01:48:09,080 --> 01:48:14,280
Again, it's easy to think of compute shaders in almost like CUDA terms.

2079
01:48:15,320 --> 01:48:19,160
One-third per pixel, and one workgroup per tile.

2080
01:48:19,880 --> 01:48:25,400
One workgroup is a term derived from compute shaders and OpenCL.

2081
01:48:26,280 --> 01:48:28,920
It's essentially what a block is in CUDA.

2082
01:48:29,960 --> 01:48:35,320
So what it's saying is one block per tile and one-third per pixel.

2083
01:48:35,320 --> 01:48:37,560
Again, very, very easy for us to understand.

2084
01:48:38,360 --> 01:48:41,000
And you get a total of n compares with atomics.

2085
01:48:41,000 --> 01:48:42,280
We haven't covered atomics yet.

2086
01:48:42,280 --> 01:48:43,880
I'll cover it on Wednesday.

2087
01:48:43,880 --> 01:48:49,880
But what that means is you can do atomic comparisons in a parallel way.

2088
01:48:49,880 --> 01:48:55,320
Of course, it becomes serial, but you'll have n comparisons per block.

2089
01:48:57,080 --> 01:48:59,960
So that way you get the result per block in a tile.

2090
01:49:01,000 --> 01:49:04,920
And then you do the light and frustum overlap.

2091
01:49:04,920 --> 01:49:08,680
So essentially, if I go back here, the first page,

2092
01:49:10,680 --> 01:49:17,240
so this 2A here is computing the minimum length of the red line.

2093
01:49:17,240 --> 01:49:18,120
Forget the blocks.

2094
01:49:18,120 --> 01:49:20,360
Forget the light, red, volume.

2095
01:49:21,080 --> 01:49:24,680
It's just computing the minimum maximum per tile, 2A.

2096
01:49:25,960 --> 01:49:28,600
2B is what is computing the volumes.

2097
01:49:30,440 --> 01:49:33,320
And for that, you're going to do, again, one block per tile,

2098
01:49:33,320 --> 01:49:38,440
one-third per light now, not per pixel.

2099
01:49:40,360 --> 01:49:46,120
And this will require multiple passes for many times, if you have a lot of them.

2100
01:49:47,720 --> 01:49:53,400
Because this here, this volume here is not just one light.

2101
01:49:55,160 --> 01:49:59,400
It can have many lights across this entire thing for the influence.

2102
01:50:00,680 --> 01:50:02,840
So you have to compute them for each object.

2103
01:50:03,480 --> 01:50:07,960
And then you do one compute shader for this and one compute shader for this.

2104
01:50:07,960 --> 01:50:09,960
And you'll end up with something like this.

2105
01:50:11,400 --> 01:50:12,360
Any questions here?

2106
01:50:19,080 --> 01:50:20,600
So let me see if...

2107
01:50:24,920 --> 01:50:29,960
Now, the third part is actually accumulating all the lights per tile

2108
01:50:30,600 --> 01:50:32,280
for the lights that affect that tile.

2109
01:50:34,280 --> 01:50:36,440
Remember, I'll say that once again.

2110
01:50:37,080 --> 01:50:41,960
You accumulate the lights in a per tile fashion

2111
01:50:42,600 --> 01:50:44,600
for the lights that only affect that tile.

2112
01:50:46,760 --> 01:50:51,880
So material IDs can be used to look up the material information from that.

2113
01:50:51,880 --> 01:50:53,720
And then you can render that into the scene.

2114
01:50:54,840 --> 01:50:59,000
So I'll play a few videos here to show how this works.

2115
01:50:59,000 --> 01:51:00,280
And this is done by students.

2116
01:51:03,960 --> 01:51:10,440
So what I'm going to do is I'm going to slow this down a little so you can absorb it.

2117
01:51:19,000 --> 01:51:22,040
So see how forward plus is much lower than...

2118
01:51:22,040 --> 01:51:24,120
Or forward is much lower than forward plus.

2119
01:51:26,360 --> 01:51:28,120
And you can see all the lights moving around

2120
01:51:28,120 --> 01:51:31,960
and how even changing the light stops influencing other parts,

2121
01:51:31,960 --> 01:51:34,040
but doesn't necessarily drop the frame rate.

2122
01:51:34,040 --> 01:51:37,800
You can see the frame rate up here when it was captured.

2123
01:51:39,880 --> 01:51:42,680
But now you'll start seeing a few debug views from this.

2124
01:51:42,680 --> 01:51:45,800
So this is how many lights are influencing each part of the scene.

2125
01:51:48,600 --> 01:51:49,800
That is the depth buffer.

2126
01:51:55,320 --> 01:51:57,480
That I believe is...

2127
01:51:59,160 --> 01:51:59,720
I forget.

2128
01:52:00,680 --> 01:52:01,640
That's normals.

2129
01:52:03,240 --> 01:52:04,680
And that's the final run.

2130
01:52:06,280 --> 01:52:08,680
So look at how many lights there are in the scene.

2131
01:52:09,640 --> 01:52:16,040
You'd find it almost impossible to do this with a regular forward rendering pipeline.

2132
01:52:21,640 --> 01:52:24,760
And I'll play another video.

2133
01:52:24,760 --> 01:52:30,840
That was a few debug views as well.

2134
01:52:41,800 --> 01:52:49,800
I'll let that play. You guys can absorb it.

2135
01:53:24,840 --> 01:53:39,800
So the thing to remember is the actual pipeline from going from primitives to rendering

2136
01:53:41,240 --> 01:53:43,160
isn't actually changing on the GPU.

2137
01:53:44,520 --> 01:53:47,640
The GPU hardware pipeline still remains the same.

2138
01:53:48,600 --> 01:53:51,720
What we're essentially doing is changing the way

2139
01:53:51,960 --> 01:53:59,720
we go from primitives and vertices all the way to the final image.

2140
01:53:59,720 --> 01:54:05,000
Instead of doing it in one pass or multiple passes of the whole pipeline over and over again,

2141
01:54:05,720 --> 01:54:09,080
we change how we store intermediate objects

2142
01:54:09,720 --> 01:54:15,320
and then come back for doing more computation that allows us to do more lights and stuff.

2143
01:54:22,200 --> 01:54:25,240
Otherwise, I'll move on from these videos.

2144
01:54:33,000 --> 01:54:36,520
So in this scene, you can also kind of see the spheres of influences and how they grow.

2145
01:54:47,240 --> 01:54:49,720
This is a very popular model, right?

2146
01:54:49,720 --> 01:54:50,760
Sponsor.

2147
01:54:50,760 --> 01:55:04,760
It's a very, very popular model to use when doing real-time rendering and showing the effects.

2148
01:55:20,040 --> 01:55:28,040
Yeah.

2149
01:55:35,000 --> 01:55:41,480
The way you have to think about it is the trade-off between compute and memory, right?

2150
01:55:41,480 --> 01:55:44,920
And that's what we said when I was introducing the Power+.

2151
01:55:45,240 --> 01:55:50,840
The computation to actually compute the minimum maximum within a tile is very, very low

2152
01:55:51,400 --> 01:55:52,840
because you're doing it within a block.

2153
01:55:52,840 --> 01:55:53,960
You're not doing it.

2154
01:55:53,960 --> 01:55:56,280
It's like doing a reduction within the block.

2155
01:55:56,840 --> 01:55:59,880
Minimum and maximum is a reduction operation, right?

2156
01:55:59,880 --> 01:56:02,760
You're comparing A greater than or less than B.

2157
01:56:03,320 --> 01:56:06,840
And you're doing it for, let's say, 16 by 16 to 256 elements.

2158
01:56:06,840 --> 01:56:08,120
You can do it in shared memory.

2159
01:56:08,680 --> 01:56:11,240
So it's very easy to do and it's very fast.

2160
01:56:11,320 --> 01:56:17,480
But if you have, let's say, thousands of lines, then that starts affecting you.

2161
01:56:17,480 --> 01:56:21,080
There may be lines that are in the background or the foreground that don't

2162
01:56:21,640 --> 01:56:23,160
affect the minimum and maximum.

2163
01:56:23,880 --> 01:56:26,120
So you can cull them away and remove them.

2164
01:56:26,120 --> 01:56:28,440
It's from the diagram I showed you.

2165
01:56:28,440 --> 01:56:29,960
It's a very, very simple diagram.

2166
01:56:30,840 --> 01:56:34,920
Real geometry can be much more complex because it also goes into 3D then.

2167
01:56:38,760 --> 01:56:39,560
Any other questions?

2168
01:56:41,240 --> 01:56:47,720
All right.

2169
01:56:48,760 --> 01:56:49,800
So those were some videos.

2170
01:56:49,800 --> 01:56:51,400
You'll have access to these, obviously.

2171
01:56:52,520 --> 01:56:55,560
So now let's see why Power Plus is faster than before.

2172
01:56:56,760 --> 01:56:57,720
In some ways, it's faster.

2173
01:56:57,720 --> 01:56:58,520
In some ways, it's slower.

2174
01:56:58,520 --> 01:57:00,120
But overall, it becomes faster.

2175
01:57:01,960 --> 01:57:10,840
The first thing is in the pre-pass, writing the gbuffer takes a lot more time

2176
01:57:10,920 --> 01:57:12,440
than writing a depth buffer.

2177
01:57:12,440 --> 01:57:15,000
In fact, depth buffer is just one part of the gbuffer.

2178
01:57:16,600 --> 01:57:23,080
So that's more information that you're going to be writing compared to just the depth buffer.

2179
01:57:24,360 --> 01:57:26,680
So Power Plus is faster so far.

2180
01:57:28,280 --> 01:57:33,800
In the lighting diagram, you're reading depth and light geometry.

2181
01:57:33,800 --> 01:57:34,360
Very simple.

2182
01:57:35,000 --> 01:57:36,840
Depth is one floating point value.

2183
01:57:36,840 --> 01:57:40,520
Light geometry is probably a few values in position and radius.

2184
01:57:41,800 --> 01:57:45,080
Then you're computing color and writing a light list.

2185
01:57:45,960 --> 01:57:50,680
All of these are way faster than the lighting accumulation in deferred,

2186
01:57:50,680 --> 01:57:52,760
where you're doing a lot more reads.

2187
01:57:52,760 --> 01:57:54,360
You're doing a lot more computation.

2188
01:57:56,120 --> 01:57:58,040
And you're accumulating the buffer.

2189
01:57:59,560 --> 01:58:01,480
Now, Power Plus is slower.

2190
01:58:02,360 --> 01:58:03,560
It's in the shading part.

2191
01:58:03,560 --> 01:58:07,320
Because now, in Power Plus, you're reading the brightness and the light drop

2192
01:58:08,200 --> 01:58:10,280
and then computing all the lighting and shading.

2193
01:58:11,320 --> 01:58:14,280
Whereas in deferred rendering, all you're doing is

2194
01:58:14,280 --> 01:58:17,560
you already have the accumulated light buffer,

2195
01:58:17,560 --> 01:58:19,560
and you're probably computing some additional shading.

2196
01:58:20,680 --> 01:58:22,600
The accumulated light buffer is coming from depth.

2197
01:58:22,600 --> 01:58:27,320
So what you write here, you're reading here, and you're doing the compute now.

2198
01:58:27,320 --> 01:58:32,280
So if we look at this comparison here, the blues are not that red.

2199
01:58:33,160 --> 01:58:35,240
The reds are very different.

2200
01:58:35,240 --> 01:58:38,760
And then the greens are slightly different, but not as much as the reds.

2201
01:58:38,760 --> 01:58:43,480
And so overall, Power Plus becomes faster,

2202
01:58:43,480 --> 01:58:49,880
because it doesn't have that high memory bandwidth usage.

2203
01:58:49,880 --> 01:58:53,880
So Power Plus is much more designed to have more compute

2204
01:58:55,080 --> 01:58:57,160
and less memory bandwidth usage.

2205
01:58:57,160 --> 01:58:58,600
And that's why it becomes faster.

2206
01:59:01,400 --> 01:59:04,760
So two scenes here, Sponza and Runhole.

2207
01:59:05,000 --> 01:59:08,280
So Sponza is a quarter million triangles.

2208
01:59:08,280 --> 01:59:10,680
Runhole is almost six million triangles.

2209
01:59:10,680 --> 01:59:12,920
So let's see how Power Plus and Power perform.

2210
01:59:13,560 --> 01:59:14,520
And this is also right here.

2211
01:59:16,600 --> 01:59:19,560
So Sponza, for 10 lights, 10 lights is like,

2212
01:59:19,560 --> 01:59:22,600
you can recharge pretty much the power every 5 minutes.

2213
01:59:22,600 --> 01:59:26,600
Well, you still see almost 2x improvement.

2214
01:59:26,600 --> 01:59:29,240
Like Power Plus is almost twice as fast,

2215
01:59:29,240 --> 01:59:32,680
or a little bit more than twice as fast as just the Power.

2216
01:59:34,920 --> 01:59:38,200
200 lights is where you start seeing slowdown.

2217
01:59:39,160 --> 01:59:40,760
So this is in milliseconds, right?

2218
01:59:40,760 --> 01:59:42,440
So this is about 6 milliseconds.

2219
01:59:43,640 --> 01:59:45,560
Very much real time, right?

2220
01:59:45,560 --> 01:59:48,840
You have at least 16 milliseconds to get 60 frames per second.

2221
01:59:49,400 --> 01:59:53,720
So this, for 10 lights, even a regular Power Plus is real time.

2222
01:59:54,520 --> 01:59:59,320
As you get to 200 lights, now this is almost 10 times as fast.

2223
02:00:01,240 --> 02:00:03,080
And then if you get to 1,000 lights,

2224
02:00:03,080 --> 02:00:07,160
now you're almost 1,500 times faster, right?

2225
02:00:07,160 --> 02:00:08,440
Or 15 times faster.

2226
02:00:09,640 --> 02:00:14,760
So that kind of shows how, as you have more lights,

2227
02:00:14,760 --> 02:00:18,040
kind of like in your GTAs or anywhere, any other game,

2228
02:00:19,000 --> 02:00:21,880
that this becomes an exponential increase.

2229
02:00:21,880 --> 02:00:26,200
And that's where changing how the pipeline works

2230
02:00:26,760 --> 02:00:29,880
is affecting games and game engines to do a lot more.

2231
02:00:30,440 --> 02:00:33,480
And that's kind of the influence behind

2232
02:00:33,480 --> 02:00:35,400
Nanite and Lumen and Unreal Engine,

2233
02:00:36,680 --> 02:00:39,800
so that you can have these different pipelines

2234
02:00:39,800 --> 02:00:41,000
as your scene grows.

2235
02:00:43,880 --> 02:00:46,280
Similarly, comparing the number of lights

2236
02:00:47,000 --> 02:00:48,920
between Power and Power Plus.

2237
02:00:51,400 --> 02:00:54,040
Runhole, which is 6 million triangles now,

2238
02:00:54,040 --> 02:00:57,480
so this was for Sponza, this is for Runhole.

2239
02:00:58,360 --> 02:01:01,480
So now we see how this changes as well.

2240
02:01:02,040 --> 02:01:05,720
Notice how the yellow bars are generally consistent.

2241
02:01:06,360 --> 02:01:08,680
So the exponential increase is not there,

2242
02:01:09,320 --> 02:01:11,960
whereas in the green, which is Power,

2243
02:01:12,920 --> 02:01:15,640
that exponential increase changes quite fast.

2244
02:01:19,160 --> 02:01:22,440
And then comparing how light radius can affect this.

2245
02:01:22,440 --> 02:01:26,520
So this is all for Sponza, all having 1,000 lights.

2246
02:01:27,160 --> 02:01:29,880
This is 1,000 small lights, 1,000 medium lights,

2247
02:01:30,520 --> 02:01:32,040
and 1,000 large lights.

2248
02:01:32,040 --> 02:01:34,440
And when we mean large, we mean a larger radius.

2249
02:01:34,440 --> 02:01:37,640
So this goes from radius of two to five to 10.

2250
02:01:38,440 --> 02:01:45,160
And you can see how in Power, the radius doesn't matter,

2251
02:01:45,160 --> 02:01:46,760
because we don't care about the radius

2252
02:01:46,760 --> 02:01:48,040
in our Power to Engine pipeline.

2253
02:01:48,040 --> 02:01:49,880
We'll just do all the lights all the time.

2254
02:01:50,520 --> 02:01:54,920
So the Power is going to remain constant and slow.

2255
02:01:56,920 --> 02:02:03,480
With Power+, now because the radius has an influence

2256
02:02:03,480 --> 02:02:05,400
on how many lights you can build

2257
02:02:05,400 --> 02:02:08,600
and how much influence it has in the geometry per tile,

2258
02:02:08,600 --> 02:02:10,760
you're going to see some performance drop off

2259
02:02:10,760 --> 02:02:12,120
as the lights become larger.

2260
02:02:13,560 --> 02:02:15,400
But it's still going to be way faster

2261
02:02:15,400 --> 02:02:17,240
than any Power rendering pipeline.

2262
02:02:19,960 --> 02:02:22,200
And then similar to Deferred,

2263
02:02:22,200 --> 02:02:25,400
when you compare the pipe sizes,

2264
02:02:25,400 --> 02:02:28,360
again, you see this sort of inverted delta,

2265
02:02:29,160 --> 02:02:33,400
where if you have eight by eight, it's kind of slow,

2266
02:02:34,040 --> 02:02:36,360
128 by 128 kind of slow.

2267
02:02:36,360 --> 02:02:40,440
But as you pick a decent size between 16 and 64,

2268
02:02:40,440 --> 02:02:42,200
you're going to get generally good results.

2269
02:02:46,920 --> 02:02:50,360
And then time spent in each pass for different tile sizes.

2270
02:02:50,360 --> 02:02:53,560
So this is tile size 16 by 16 and 32 by 32.

2271
02:02:54,120 --> 02:02:58,760
And that changes based on your compute pass.

2272
02:02:58,760 --> 02:03:01,160
So 32 by 32, you're going to take longer

2273
02:03:01,160 --> 02:03:02,920
because it's a larger block.

2274
02:03:02,920 --> 02:03:05,880
You're going to take more time to compute the min and max.

2275
02:03:05,880 --> 02:03:09,000
But because you take more time and your tile is bigger,

2276
02:03:09,640 --> 02:03:15,960
your final stage pass is going to be longer.

2277
02:03:16,360 --> 02:03:24,360
Whereas in 16 by 16, your compute pass is longer,

2278
02:03:24,360 --> 02:03:26,120
but your final pass is shorter.

2279
02:03:30,360 --> 02:03:30,760
Okay.

2280
02:03:30,760 --> 02:03:33,720
So any questions on that so far on Power Plus?

2281
02:03:36,840 --> 02:03:38,200
Because next we are going to see

2282
02:03:38,200 --> 02:03:40,040
how do we optimize Power Plus even more.

2283
02:03:46,360 --> 02:03:46,760
All right.

2284
02:03:48,360 --> 02:03:51,480
So the next step of optimization,

2285
02:03:51,480 --> 02:03:53,640
again, if you know anything about Green by Now,

2286
02:03:53,640 --> 02:03:55,720
we'll always have slides that are,

2287
02:03:55,720 --> 02:03:57,800
okay, how do we take this and optimize it more, right?

2288
02:03:58,680 --> 02:04:00,920
Performance Lab is the number one example of that.

2289
02:04:02,120 --> 02:04:04,680
So let's say we don't want,

2290
02:04:04,680 --> 02:04:06,280
we're not satisfied with a thousand lights,

2291
02:04:06,280 --> 02:04:07,560
we want a million lights.

2292
02:04:08,600 --> 02:04:09,800
Office Power is one million.

2293
02:04:12,520 --> 02:04:14,280
Let's see how to do that.

2294
02:04:15,240 --> 02:04:18,440
What we'll call this is cluster trading essentially,

2295
02:04:18,440 --> 02:04:20,760
and this is used by some of the most modern games.

2296
02:04:23,000 --> 02:04:24,680
It has better worst case performance,

2297
02:04:24,680 --> 02:04:28,920
but with large depth discontinuities,

2298
02:04:28,920 --> 02:04:30,440
and I'll get to that in a little bit.

2299
02:04:31,720 --> 02:04:33,080
And let's see how that...

2300
02:04:33,080 --> 02:04:34,200
So in cluster trading,

2301
02:04:35,400 --> 02:04:38,120
the same that we found that we did in Power Plus,

2302
02:04:39,160 --> 02:04:41,480
but now instead of doing full volumes,

2303
02:04:41,480 --> 02:04:43,320
we'll do clusters, okay?

2304
02:04:43,400 --> 02:04:44,680
And I'll show you an image of that.

2305
02:04:45,720 --> 02:04:47,960
And we want to remove any empty space.

2306
02:04:49,160 --> 02:04:50,680
And then the light coming

2307
02:04:50,680 --> 02:04:53,000
is assigned only to the non-empty clusters.

2308
02:04:53,800 --> 02:04:55,800
And then the final shading is, again,

2309
02:04:55,800 --> 02:04:57,560
same as the Power Plus.

2310
02:04:58,200 --> 02:04:59,560
So let's take a look.

2311
02:04:59,560 --> 02:05:02,520
So this is actually the same as what we found in Power Plus.

2312
02:05:02,520 --> 02:05:05,560
So this is how the depth buffer looks from top down.

2313
02:05:07,240 --> 02:05:10,520
In Power Plus, we get this kind of range,

2314
02:05:11,480 --> 02:05:13,960
but now, say clusters,

2315
02:05:13,960 --> 02:05:16,120
we're not just dividing the tiles like this,

2316
02:05:16,760 --> 02:05:19,400
we're dividing the whole scene into this.

2317
02:05:19,400 --> 02:05:21,640
So we're not just getting the tiles here,

2318
02:05:21,640 --> 02:05:24,920
we're also dividing that by the depth, okay?

2319
02:05:25,720 --> 02:05:29,240
So what that does is it removes

2320
02:05:29,960 --> 02:05:32,600
coverage on the bottom volume that we have.

2321
02:05:33,240 --> 02:05:35,240
So this is a prime example of this.

2322
02:05:35,240 --> 02:05:39,000
Look at this, how this line is going from here to here.

2323
02:05:39,560 --> 02:05:42,840
But now, because this is divided like this as well,

2324
02:05:42,840 --> 02:05:45,160
we don't have to draw a full box here,

2325
02:05:45,160 --> 02:05:46,680
we can just draw small chunks.

2326
02:05:47,880 --> 02:05:52,280
That's min and max, both in depth for this,

2327
02:05:52,280 --> 02:05:54,200
and then the x, y, and z.

2328
02:05:55,240 --> 02:05:58,680
And then similarly, look at this bounding volume here,

2329
02:05:59,240 --> 02:06:01,800
where you have a little bit in the back

2330
02:06:01,800 --> 02:06:03,160
and a little bit in the foreground.

2331
02:06:03,800 --> 02:06:06,840
What we'll do here is we have one cluster there

2332
02:06:07,800 --> 02:06:09,160
and one cluster here, that's it.

2333
02:06:09,880 --> 02:06:13,000
All this empty space where there's nothing gets removed.

2334
02:06:13,000 --> 02:06:15,720
We don't have, in Power Plus,

2335
02:06:16,680 --> 02:06:19,080
this would have meant if a light was like here,

2336
02:06:19,080 --> 02:06:19,720
influencing here,

2337
02:06:19,720 --> 02:06:21,640
we still have to do the computation of all that.

2338
02:06:22,360 --> 02:06:24,280
But here, there's a light influencing here,

2339
02:06:24,280 --> 02:06:25,080
we don't do anything.

2340
02:06:26,040 --> 02:06:27,720
We just, we cut it out.

2341
02:06:28,280 --> 02:06:32,360
So this is essentially improving

2342
02:06:33,240 --> 02:06:39,560
how well lights get curled within our scenes,

2343
02:06:39,560 --> 02:06:41,000
even better than Power Plus.

2344
02:06:41,960 --> 02:06:44,680
So traditional tile depth range

2345
02:06:44,680 --> 02:06:47,720
is often much larger than needed,

2346
02:06:48,280 --> 02:06:49,640
because you're going to have gaps

2347
02:06:49,640 --> 02:06:51,800
like we see in this third one.

2348
02:06:51,800 --> 02:06:53,160
You're going to have something in the front

2349
02:06:53,160 --> 02:06:54,600
and then something in the back,

2350
02:06:54,600 --> 02:06:57,640
and you want to get rid of whatever is in the middle.

2351
02:06:58,200 --> 02:07:00,760
So clusters are essentially walk cells

2352
02:07:02,200 --> 02:07:04,840
in our 3D space for geometry and lights.

2353
02:07:07,400 --> 02:07:09,000
So now, pairing...

2354
02:07:09,000 --> 02:07:11,000
This is the simplest way.

2355
02:07:11,000 --> 02:07:15,560
So, green is the explicit.

2356
02:07:15,560 --> 02:07:17,160
So if you get the color,

2357
02:07:17,160 --> 02:07:21,560
if you're trying not to do the super compressed version,

2358
02:07:21,560 --> 02:07:23,240
you can do the green version.

2359
02:07:23,240 --> 02:07:24,680
But the blue version is going to be

2360
02:07:24,680 --> 02:07:26,600
the most explicit founding body

2361
02:07:27,480 --> 02:07:31,000
that you have for the coverage in each cluster.

2362
02:07:33,880 --> 02:07:36,040
So let's say we have,

2363
02:07:36,040 --> 02:07:38,280
we take this example, we have three lights.

2364
02:07:39,880 --> 02:07:42,760
So light one doesn't affect anything, right?

2365
02:07:43,400 --> 02:07:44,760
Everything can get rid of it.

2366
02:07:45,800 --> 02:07:47,480
Light two doesn't affect anything,

2367
02:07:47,480 --> 02:07:48,760
even though it's closer,

2368
02:07:48,760 --> 02:07:49,960
it doesn't affect anything

2369
02:07:49,960 --> 02:07:51,880
so we can completely get rid of it.

2370
02:07:53,160 --> 02:07:55,800
And these two happen in both Forward Plus

2371
02:07:55,800 --> 02:07:57,800
and Forward Plus clusters.

2372
02:07:57,800 --> 02:07:59,800
We don't have to use these lights, one and two.

2373
02:08:00,600 --> 02:08:02,520
But three is where the magic happens.

2374
02:08:03,800 --> 02:08:07,320
For three, this time,

2375
02:08:08,440 --> 02:08:10,840
and this time we'll be computing with it

2376
02:08:10,840 --> 02:08:13,160
along with time four, right?

2377
02:08:15,480 --> 02:08:16,840
In clustered, however,

2378
02:08:18,920 --> 02:08:21,720
none of these times have to interact with light three,

2379
02:08:22,280 --> 02:08:25,640
only these two times interact with light three, right?

2380
02:08:25,800 --> 02:08:28,280
So now you see how many clusters

2381
02:08:28,280 --> 02:08:29,080
you're getting rid of

2382
02:08:29,080 --> 02:08:31,160
that don't have to interact with light three at all.

2383
02:08:33,240 --> 02:08:36,440
And that means you're removing a bunch of geometry

2384
02:08:36,440 --> 02:08:38,200
that doesn't have to interact with light three.

2385
02:08:40,120 --> 02:08:44,520
So you're going from what was 2D into 3D clusters,

2386
02:08:44,520 --> 02:08:47,560
and you're helping optimize the lights even further.

2387
02:08:49,880 --> 02:08:53,960
And uniform is not the only way to divide clusters.

2388
02:08:53,960 --> 02:08:55,720
You can divide it in different strategies

2389
02:08:55,720 --> 02:08:57,160
depending on how you're seeing them.

2390
02:08:57,880 --> 02:09:01,640
So for example, you can have this divided

2391
02:09:01,640 --> 02:09:06,600
in uniform normalized device coordinates

2392
02:09:06,600 --> 02:09:08,600
or normalized display coordinates.

2393
02:09:08,600 --> 02:09:11,720
You can have uniform like we were showing in this,

2394
02:09:11,720 --> 02:09:12,680
these are all uniform.

2395
02:09:13,800 --> 02:09:15,240
Or you can have exponential

2396
02:09:15,240 --> 02:09:17,560
where it just increases as you go along.

2397
02:09:19,000 --> 02:09:23,480
So you can vary depending on what your scene looks like.

2398
02:09:24,040 --> 02:09:26,680
If your scene has a lot more information up close,

2399
02:09:26,680 --> 02:09:28,680
you may want more clusters up close

2400
02:09:28,680 --> 02:09:30,040
and less clusters in the back.

2401
02:09:31,320 --> 02:09:34,840
If you have fog that is hiding everything in the back,

2402
02:09:34,840 --> 02:09:38,520
use uniform NDC and get rid of everything in the back.

2403
02:09:38,520 --> 02:09:40,680
So you can choose your strategy for dividing it.

2404
02:09:41,800 --> 02:09:44,280
Another way to look at it is like this,

2405
02:09:44,280 --> 02:09:47,400
where you have exponential spacing

2406
02:09:47,400 --> 02:09:49,160
and you have special near clusters

2407
02:09:49,160 --> 02:09:52,760
where if you have a lot of geometry here,

2408
02:09:52,760 --> 02:09:53,800
you may come to know, okay,

2409
02:09:53,800 --> 02:09:55,080
it's not even worth dividing it

2410
02:09:55,080 --> 02:09:58,040
because all the clusters will interact with all the maps.

2411
02:09:58,040 --> 02:09:59,960
So if you have, let's say a line like this,

2412
02:10:03,240 --> 02:10:05,960
all the clusters, even if you're in the white area,

2413
02:10:05,960 --> 02:10:08,360
are going to interact with that, right?

2414
02:10:08,360 --> 02:10:10,600
So it's kind of pointless to divide it into clusters.

2415
02:10:10,600 --> 02:10:12,360
So you may be like, okay,

2416
02:10:12,360 --> 02:10:15,000
let me just get rid of clusters in that area

2417
02:10:15,000 --> 02:10:17,080
and then start my clusters there.

2418
02:10:17,080 --> 02:10:18,760
But there are different strategies you can use.

2419
02:10:18,760 --> 02:10:20,520
There's no one right answer.

2420
02:10:20,520 --> 02:10:23,880
You can choose the strategy that works best for your use.

2421
02:10:25,720 --> 02:10:27,880
Any questions so far on clusters?

2422
02:10:34,840 --> 02:10:36,360
Remember, this is all project five.

2423
02:10:36,360 --> 02:10:38,840
If you do the WebGL project, this is all project five.

2424
02:10:40,600 --> 02:10:42,360
You're going to be implementing these pipelines

2425
02:10:42,360 --> 02:10:43,160
in project five.

2426
02:10:44,040 --> 02:10:49,720
Okay, all right.

2427
02:10:49,720 --> 02:10:51,160
So for the culling part,

2428
02:10:51,160 --> 02:10:53,720
now again, looking at it from top down,

2429
02:10:54,360 --> 02:10:55,800
if you have a light like this,

2430
02:10:57,720 --> 02:10:59,800
you want to cull out different parts of it, right?

2431
02:10:59,800 --> 02:11:05,080
So the traditional approach is checking of six frustums.

2432
02:11:05,080 --> 02:11:06,440
Remember, this is in 3D.

2433
02:11:06,440 --> 02:11:07,480
If you have a sphere,

2434
02:11:08,200 --> 02:11:12,200
you need to check minimum, maximum along each dimension.

2435
02:11:13,800 --> 02:11:16,280
So the planes have a lot of false intersections.

2436
02:11:17,480 --> 02:11:19,880
That is, if you have...

2437
02:11:35,720 --> 02:11:36,920
What we are essentially saying,

2438
02:11:37,640 --> 02:11:40,360
even though these four are the boundary planes

2439
02:11:40,360 --> 02:11:41,880
that encompass the light,

2440
02:11:41,880 --> 02:11:45,400
even within these, you can have false betweens

2441
02:11:46,120 --> 02:11:48,360
where the light doesn't retract that cluster.

2442
02:11:49,720 --> 02:11:57,880
Okay, so AABB, like you may have seen in your path traces,

2443
02:11:57,880 --> 02:11:59,480
when you import a mesh,

2444
02:11:59,480 --> 02:12:02,840
you don't access align bounding box around it.

2445
02:12:02,840 --> 02:12:04,360
You can still hit the bounding box,

2446
02:12:04,360 --> 02:12:06,040
but miss the mesh space.

2447
02:12:06,040 --> 02:12:08,440
The mesh doesn't cover the entire bounding box.

2448
02:12:09,160 --> 02:12:10,600
Same thing happening here.

2449
02:12:10,600 --> 02:12:12,360
This is the bounding box for the light

2450
02:12:12,360 --> 02:12:13,880
in terms of the clusters,

2451
02:12:14,520 --> 02:12:17,480
but you get clusters that are not affected by the light.

2452
02:12:20,120 --> 02:12:22,360
So that's kind of what you want to improve

2453
02:12:22,360 --> 02:12:28,760
is don't intersect by the planes of the frustums,

2454
02:12:28,760 --> 02:12:32,360
but they need to access align bounding box for the lights.

2455
02:12:34,680 --> 02:12:38,600
So now if you look at this in an image that we saw before,

2456
02:12:39,240 --> 02:12:41,720
now we start seeing this kind of thing

2457
02:12:41,720 --> 02:12:44,840
where the tiles that interact with the tree

2458
02:12:44,840 --> 02:12:47,800
first start here and go all the way to the back.

2459
02:12:48,440 --> 02:12:50,920
But anything that doesn't start with the tree,

2460
02:12:50,920 --> 02:12:54,520
for example, these lines here are much smaller.

2461
02:12:55,720 --> 02:12:57,320
And then you have some clusters here

2462
02:12:57,320 --> 02:12:58,360
that are only the ones.

2463
02:12:59,720 --> 02:13:02,040
So you save a lot of space here

2464
02:13:02,760 --> 02:13:05,160
where nothing has to interact with the lights.

2465
02:13:06,040 --> 02:13:09,160
So if I show this in a different way,

2466
02:13:09,720 --> 02:13:12,840
where we show the end of endpoint of the clusters,

2467
02:13:12,840 --> 02:13:14,280
this is what it looks like.

2468
02:13:14,280 --> 02:13:16,040
Some of them are hitting the ground,

2469
02:13:16,040 --> 02:13:17,960
some of them are hitting the boundary,

2470
02:13:17,960 --> 02:13:19,400
some of them are hitting the tree.

2471
02:13:20,440 --> 02:13:23,960
So this, so let me, let me go back.

2472
02:13:24,680 --> 02:13:27,880
This is forward plus, right?

2473
02:13:27,880 --> 02:13:31,560
Where you have the starting and the end, okay?

2474
02:13:32,120 --> 02:13:33,160
And this is cluster.

2475
02:13:33,160 --> 02:13:34,200
And this is cluster.

2476
02:13:35,080 --> 02:13:35,580
Why?

2477
02:13:36,360 --> 02:13:39,880
Because sponsor has a lot of space in the middle.

2478
02:13:39,880 --> 02:13:45,240
So what power plus is showing here is empty space, right?

2479
02:13:45,240 --> 02:13:46,040
It's just air.

2480
02:13:47,000 --> 02:13:48,920
We don't have to do that in cluster.

2481
02:13:48,920 --> 02:13:51,400
In cluster, you just get rid of all of it.

2482
02:13:52,840 --> 02:13:54,840
So you are only left with places

2483
02:13:54,840 --> 02:13:56,200
where there's actual geometry.

2484
02:13:57,720 --> 02:14:01,960
So instead of having 2D tiles that have a min and max,

2485
02:14:02,680 --> 02:14:04,360
you work into clusters,

2486
02:14:04,360 --> 02:14:08,280
which are much more compact in their size.

2487
02:14:11,320 --> 02:14:12,360
Any questions on this?

2488
02:14:18,360 --> 02:14:19,880
Everybody ready for project five?

2489
02:14:19,880 --> 02:14:21,240
Maybe you'll send that out now.

2490
02:14:23,560 --> 02:14:24,040
Hey, Alex?

2491
02:14:32,840 --> 02:14:35,080
Yeah, it has to do with global illumination.

2492
02:14:35,080 --> 02:14:37,160
It also has to do with modern games.

2493
02:14:37,160 --> 02:14:39,400
Like there's, there's a axiom, right?

2494
02:14:42,120 --> 02:14:44,920
Rendering artists and game developers

2495
02:14:45,880 --> 02:14:49,480
will always improve the quality of their scenes

2496
02:14:49,480 --> 02:14:50,520
to fill up the GPU.

2497
02:14:51,160 --> 02:14:53,240
And when can AMD come up with a new GPU?

2498
02:14:54,120 --> 02:14:56,360
All the games are going to maximize to take advantage of.

2499
02:14:57,320 --> 02:15:00,680
No matter, even if you have five generations of GPU

2500
02:15:01,000 --> 02:15:03,000
today, imagine if you could do that.

2501
02:15:04,520 --> 02:15:07,080
Today's game developers are ready to take advantage of all.

2502
02:15:08,040 --> 02:15:11,800
There's no end to how much quality game developers

2503
02:15:11,800 --> 02:15:13,720
and artists want to add into your scenes.

2504
02:15:14,760 --> 02:15:18,200
If you give them the capability to add a million lights,

2505
02:15:18,200 --> 02:15:19,400
they will add a million lights.

2506
02:15:19,400 --> 02:15:21,560
They'll add a light on every single car,

2507
02:15:21,560 --> 02:15:24,280
on every single street lamp, wherever it might be.

2508
02:15:24,920 --> 02:15:31,640
So being able to allow the complex geometry,

2509
02:15:31,640 --> 02:15:33,320
the complex lighting and materials

2510
02:15:33,320 --> 02:15:35,800
that modern games and real-time rendering want,

2511
02:15:36,440 --> 02:15:37,880
and not just games and rendering,

2512
02:15:37,880 --> 02:15:41,560
but also simulation, like how Eric showed the other day,

2513
02:15:41,560 --> 02:15:45,160
that we are using this in industrial applications and stuff.

2514
02:15:46,200 --> 02:15:48,600
You want to have the ability to render

2515
02:15:48,600 --> 02:15:50,040
any type of scene that you want.

2516
02:15:50,600 --> 02:15:51,800
Any other questions here?

2517
02:15:55,000 --> 02:15:55,500
Okay.

2518
02:15:58,360 --> 02:16:02,040
So here's a video of cluster trading.

2519
02:16:04,040 --> 02:16:06,600
And this is captioned, so I'll let that play around.

2520
02:16:06,600 --> 02:16:08,360
And you can see how fast it's working.

2521
02:16:21,000 --> 02:16:24,440
So you see the tiles here, and that's what's blocking.

2522
02:16:24,440 --> 02:16:50,200
So that was with 2,500 lights, 5.6 milliseconds

2523
02:16:50,200 --> 02:16:51,480
for the worst case test.

2524
02:16:51,480 --> 02:16:52,520
So it's pretty fast.

2525
02:16:55,400 --> 02:16:56,600
So what we haven't covered?

2526
02:16:56,600 --> 02:17:01,960
So I showed deferred and forward plus and cluster forward.

2527
02:17:02,520 --> 02:17:03,880
There are other parallel approaches

2528
02:17:03,880 --> 02:17:05,400
that you can do for light culling.

2529
02:17:05,400 --> 02:17:07,160
That's certainly something we didn't cover.

2530
02:17:07,160 --> 02:17:09,400
There's plenty of SIGGRAPH tables around this.

2531
02:17:10,040 --> 02:17:12,520
If you look at the latest and advanced

2532
02:17:12,520 --> 02:17:14,440
in real-time rendering talk at SIGGRAPH,

2533
02:17:14,440 --> 02:17:16,920
you're going to find plenty of things every single year

2534
02:17:16,920 --> 02:17:21,720
that essentially improve how we do rendering for games.

2535
02:17:21,720 --> 02:17:23,240
We also didn't cover shadows.

2536
02:17:23,240 --> 02:17:25,000
Shadows are a big, complex part.

2537
02:17:25,000 --> 02:17:26,840
Right now, we have only focused on how do you

2538
02:17:26,840 --> 02:17:28,040
render the scene with lights.

2539
02:17:28,040 --> 02:17:30,840
We haven't done too many passes, alpha blending,

2540
02:17:30,840 --> 02:17:31,560
those kind of things.

2541
02:17:32,840 --> 02:17:36,360
And we've also not taken a look at various different types

2542
02:17:36,360 --> 02:17:36,680
of lights.

2543
02:17:36,680 --> 02:17:39,320
Forward plus, we focused more on the point light approach.

2544
02:17:39,320 --> 02:17:42,440
So there's a lot more both in GPU Pro,

2545
02:17:42,440 --> 02:17:45,640
real-time rendering, and others to check out

2546
02:17:45,640 --> 02:17:49,720
about newer pipelines that you may want to explore.

2547
02:17:49,800 --> 02:17:54,280
A bunch of resources here, both former student projects

2548
02:17:54,280 --> 02:17:57,880
as well as other courses from SIGGRAPH

2549
02:17:57,880 --> 02:17:59,240
and other conferences.

2550
02:17:59,240 --> 02:18:01,320
I haven't updated this list in a while,

2551
02:18:01,320 --> 02:18:04,840
so please feel free to recommend any courses you find

2552
02:18:04,840 --> 02:18:07,320
at SIGGRAPH or elsewhere that I should be adding here.

2553
02:18:09,560 --> 02:18:13,000
Some resources on Clustered that you can also check out.

2554
02:18:14,200 --> 02:18:17,240
And finally, a comparison of all the different approaches

2555
02:18:17,880 --> 02:18:18,360
we've used.

2556
02:18:18,360 --> 02:18:22,360
We started with Clustered Different,

2557
02:18:22,360 --> 02:18:24,360
Clustered Different, Clustered Forward.

2558
02:18:24,360 --> 02:18:26,360
Clustered Different wasn't something

2559
02:18:26,360 --> 02:18:31,080
we touched on in the beginning, but it is a way to do it.

2560
02:18:31,080 --> 02:18:33,080
And then we had time to start formulating it.

2561
02:18:33,720 --> 02:18:36,520
Of course, different pipelines have different advantages

2562
02:18:36,520 --> 02:18:37,880
and disadvantages.

2563
02:18:37,880 --> 02:18:40,280
It is up to the game you're developing

2564
02:18:40,280 --> 02:18:41,720
to choose which pipeline you want.

2565
02:18:41,720 --> 02:18:44,760
If you're developing your 2D with one light,

2566
02:18:44,760 --> 02:18:46,520
you probably don't care about anything else.

2567
02:18:46,520 --> 02:18:47,720
You don't care about any of them.

2568
02:18:47,720 --> 02:18:50,520
You can just do a simple forward rendering pipeline

2569
02:18:50,520 --> 02:18:53,800
and forget about all of this, because your compute requirement

2570
02:18:53,800 --> 02:18:54,920
is not going to be that much.

2571
02:18:55,640 --> 02:18:57,480
But if you are in the GTAs of the world,

2572
02:18:57,480 --> 02:18:58,760
where you have thousands of lights,

2573
02:18:59,640 --> 02:19:01,400
you're probably going to care about one of these,

2574
02:19:01,400 --> 02:19:04,280
if not a more advanced pipeline that you may want to run.

2575
02:19:06,360 --> 02:19:09,000
So yeah, that's all for today's lecture.

2576
02:19:10,120 --> 02:19:12,680
Again, reminder that Project 4 is out.

2577
02:19:12,680 --> 02:19:13,720
We've released it.

2578
02:19:13,800 --> 02:19:17,640
If you want 21st and then both deferred and forward plus

2579
02:19:17,640 --> 02:19:22,440
will be one part of, or one optional part of Project 5.

2580
02:19:22,440 --> 02:19:23,720
So if you have any questions,

2581
02:19:23,720 --> 02:19:27,080
please review the slides and bring your questions.

2582
02:19:29,080 --> 02:19:29,960
That's all for today.

2583
02:19:33,080 --> 02:19:37,400
21st, on the calendar.

2584
02:19:37,960 --> 02:19:38,920
I don't remember.

2585
02:19:44,200 --> 02:19:44,680
Might be.

2586
02:19:46,760 --> 02:19:49,880
And then you'll have a break between when Project 5 is due

2587
02:19:49,880 --> 02:19:51,000
and when final projects start.

2588
02:19:51,000 --> 02:19:52,200
So that's the break you get.

2589
02:19:54,920 --> 02:19:56,360
Before we had six projects.

2590
02:19:57,000 --> 02:19:58,920
And the sixth project would essentially run

2591
02:19:58,920 --> 02:20:02,120
from end of Project 5 to start of final projects.

2592
02:20:02,120 --> 02:20:03,320
And I got rid of that.

2593
02:20:03,320 --> 02:20:09,400
It was too much for students.

